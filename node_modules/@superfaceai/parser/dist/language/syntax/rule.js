"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SyntaxRuleDebugLog = exports.SyntaxRuleNever = exports.SyntaxRuleMutable = exports.SyntaxRuleAndThen = exports.SyntaxRuleMap = exports.SyntaxRuleLookahead = exports.SyntaxRuleOptional = exports.SyntaxRuleRepeat = exports.SyntaxRuleFollowedBy = exports.SyntaxRuleOr = exports.SyntaxRuleJessie = exports.SyntaxRuleNewline = exports.SyntaxRuleString = exports.SyntaxRuleLiteral = exports.SyntaxRuleIdentifier = exports.SyntaxRuleOperator = exports.SyntaxRuleSeparator = exports.SyntaxRule = exports.MatchAttempts = void 0;
var token_1 = require("../lexer/token");
var MatchAttempts = /** @class */ (function () {
    function MatchAttempts(
    /** Token at which the rules failed */
    token, 
    /** Rules which failed at the token */
    rules) {
        this.token = token;
        this.rules = rules;
    }
    MatchAttempts.merge = function (first, second) {
        if (first === undefined) {
            return second;
        }
        return first.merge(second);
    };
    /** Merges two rule attempts according to the furthest token heuristic. */
    MatchAttempts.prototype.merge = function (other) {
        if (other === undefined) {
            return this;
        }
        // resolve undefined
        if (this.token === undefined && other.token === undefined) {
            return new MatchAttempts(this.token, __spreadArray(__spreadArray([], __read(this.rules)), __read(other.rules)));
        }
        // undefined is treated as greater than defined
        if (this.token === undefined) {
            return this;
        }
        else if (other.token === undefined) {
            return other;
        }
        // if the tokens are of UNKNOWN variant then we compare their error spans instead
        var thisLocation = this.token.data.kind === 0 /* UNKNOWN */
            ? this.token.data.error.location
            : this.token.location;
        var otherLocation = other.token.data.kind === 0 /* UNKNOWN */
            ? other.token.data.error.location
            : other.token.location;
        if (thisLocation.start.charIndex === otherLocation.start.charIndex) {
            return new MatchAttempts(this.token, __spreadArray(__spreadArray([], __read(this.rules)), __read(other.rules)));
        }
        if (thisLocation.start.charIndex > otherLocation.start.charIndex) {
            return this;
        }
        else {
            return other;
        }
    };
    return MatchAttempts;
}());
exports.MatchAttempts = MatchAttempts;
var SyntaxRule = /** @class */ (function () {
    function SyntaxRule() {
    }
    SyntaxRule.prototype.simpleTryMatchBoilerplate = function (tokens, predicate, context) {
        var save = tokens.save();
        var next = tokens.next(context);
        if (next.done === false) {
            var token = next.value;
            var match = predicate(token);
            if (match !== undefined) {
                return {
                    kind: 'match',
                    match: match,
                };
            }
        }
        tokens.rollback(save);
        return {
            kind: 'nomatch',
            attempts: new MatchAttempts(next.value, [this]),
        };
    };
    SyntaxRule.prototype.toString = function () {
        return this[Symbol.toStringTag]();
    };
    // Factory methods for basic rules
    SyntaxRule.separator = function (separator) {
        return new SyntaxRuleSeparator(separator);
    };
    SyntaxRule.operator = function (operator) {
        return new SyntaxRuleOperator(operator);
    };
    SyntaxRule.identifier = function (identifier) {
        return new SyntaxRuleIdentifier(identifier);
    };
    SyntaxRule.literal = function () {
        return new SyntaxRuleLiteral();
    };
    SyntaxRule.string = function () {
        return new SyntaxRuleString();
    };
    SyntaxRule.newline = function () {
        return new SyntaxRuleNewline();
    };
    SyntaxRule.jessie = function (terminatingChars) {
        return new SyntaxRuleJessie(terminatingChars);
    };
    // Combinators
    SyntaxRule.prototype.or = function (rule) {
        return new SyntaxRuleOr(this, rule);
    };
    /**
     * To cascade multiple `followedBy` rules, use `.andFollowedBy` method on the
     * `SyntaxRuleFollowedBy` object that is returned to flatten nested tuples.
     */
    SyntaxRule.prototype.followedBy = function (rule) {
        return new SyntaxRuleFollowedBy(this.map(function (m) { return [m]; }), rule);
    };
    // Cannot return `SyntaxRuleMap` because that would confuse TS into thinking `SyntaxRule` is contravariant over `T`
    SyntaxRule.prototype.map = function (mapper) {
        return new SyntaxRuleMap(this, mapper);
    };
    SyntaxRule.prototype.andThen = function (then, description) {
        return new SyntaxRuleAndThen(this, then, description);
    };
    /** Ensures that `this` is followed by `rule` without consuming any tokens after `this`. */
    SyntaxRule.prototype.lookahead = function (rule) {
        return this.followedBy(new SyntaxRuleLookahead(rule)).map(function (_a) {
            var _b = __read(_a, 2), me = _b[0], _lookahead = _b[1];
            return me;
        });
    };
    /** Skips `rule` following `this` without affecting the returned type. */
    SyntaxRule.prototype.skip = function (rule) {
        return this.followedBy(rule).map(function (_a) {
            var _b = __read(_a, 2), me = _b[0], _skipped = _b[1];
            return me;
        });
    };
    /** Forgets `this` and expectes `rule` to follow. */
    SyntaxRule.prototype.forgetFollowedBy = function (rule) {
        return this.followedBy(rule).map(function (_a) {
            var _b = __read(_a, 2), _me = _b[0], newres = _b[1];
            return newres;
        });
    };
    SyntaxRule.repeat = function (rule) {
        return new SyntaxRuleRepeat(rule);
    };
    SyntaxRule.optional = function (rule) {
        return new SyntaxRuleOptional(rule);
    };
    /**
     * Returns `rule` that cannot be preceded by a newline.
     * Example usage: `SyntaxRule.identifier('slot').followedBy(SyntaxRule.sameLine(SyntaxRule.string()))`
     */
    SyntaxRule.sameLine = function (rule) {
        return new SyntaxRuleLookahead(SyntaxRule.newline(), true)
            .followedBy(rule)
            .map(function (_a) {
            var _b = __read(_a, 2), _ = _b[0], r = _b[1];
            return r;
        });
    };
    SyntaxRule.prototype.debug = function () {
        return new SyntaxRuleDebugLog(this);
    };
    return SyntaxRule;
}());
exports.SyntaxRule = SyntaxRule;
// BASIC //
var SyntaxRuleSeparator = /** @class */ (function (_super) {
    __extends(SyntaxRuleSeparator, _super);
    function SyntaxRuleSeparator(separator) {
        var _this = _super.call(this) || this;
        _this.separator = separator;
        return _this;
    }
    SyntaxRuleSeparator.prototype.tryMatch = function (tokens) {
        var _this = this;
        return this.simpleTryMatchBoilerplate(tokens, function (token) {
            if (token.data.kind === 1 /* SEPARATOR */) {
                if (_this.separator === undefined ||
                    token.data.separator === _this.separator) {
                    return {
                        data: token.data,
                        location: token.location,
                    };
                }
            }
            return undefined;
        });
    };
    SyntaxRuleSeparator.prototype[Symbol.toStringTag] = function () {
        if (this.separator !== undefined) {
            return '`' + this.separator + '`';
        }
        return token_1.formatTokenKind(1 /* SEPARATOR */);
    };
    return SyntaxRuleSeparator;
}(SyntaxRule));
exports.SyntaxRuleSeparator = SyntaxRuleSeparator;
var SyntaxRuleOperator = /** @class */ (function (_super) {
    __extends(SyntaxRuleOperator, _super);
    function SyntaxRuleOperator(operator) {
        var _this = _super.call(this) || this;
        _this.operator = operator;
        return _this;
    }
    SyntaxRuleOperator.prototype.tryMatch = function (tokens) {
        var _this = this;
        return this.simpleTryMatchBoilerplate(tokens, function (token) {
            if (token.data.kind === 2 /* OPERATOR */) {
                if (_this.operator === undefined ||
                    token.data.operator === _this.operator) {
                    return {
                        data: token.data,
                        location: token.location,
                    };
                }
            }
            return undefined;
        });
    };
    SyntaxRuleOperator.prototype[Symbol.toStringTag] = function () {
        if (this.operator !== undefined) {
            return '`' + this.operator + '`';
        }
        return token_1.formatTokenKind(2 /* OPERATOR */);
    };
    return SyntaxRuleOperator;
}(SyntaxRule));
exports.SyntaxRuleOperator = SyntaxRuleOperator;
var SyntaxRuleIdentifier = /** @class */ (function (_super) {
    __extends(SyntaxRuleIdentifier, _super);
    function SyntaxRuleIdentifier(identifier) {
        var _this = _super.call(this) || this;
        _this.identifier = identifier;
        return _this;
    }
    SyntaxRuleIdentifier.prototype.tryMatch = function (tokens) {
        var _this = this;
        return this.simpleTryMatchBoilerplate(tokens, function (token) {
            if (token.data.kind === 5 /* IDENTIFIER */) {
                if (_this.identifier === undefined ||
                    token.data.identifier === _this.identifier) {
                    return {
                        data: token.data,
                        location: token.location,
                    };
                }
            }
            return undefined;
        });
    };
    SyntaxRuleIdentifier.prototype[Symbol.toStringTag] = function () {
        if (this.identifier !== undefined) {
            return '`' + this.identifier + '`';
        }
        return token_1.formatTokenKind(5 /* IDENTIFIER */);
    };
    return SyntaxRuleIdentifier;
}(SyntaxRule));
exports.SyntaxRuleIdentifier = SyntaxRuleIdentifier;
var SyntaxRuleLiteral = /** @class */ (function (_super) {
    __extends(SyntaxRuleLiteral, _super);
    function SyntaxRuleLiteral() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SyntaxRuleLiteral.prototype.tryMatch = function (tokens) {
        return this.simpleTryMatchBoilerplate(tokens, function (token) {
            if (token.data.kind === 3 /* LITERAL */) {
                return {
                    data: token.data,
                    location: token.location,
                };
            }
            return undefined;
        });
    };
    SyntaxRuleLiteral.prototype[Symbol.toStringTag] = function () {
        return token_1.formatTokenKind(3 /* LITERAL */);
    };
    return SyntaxRuleLiteral;
}(SyntaxRule));
exports.SyntaxRuleLiteral = SyntaxRuleLiteral;
var SyntaxRuleString = /** @class */ (function (_super) {
    __extends(SyntaxRuleString, _super);
    function SyntaxRuleString() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SyntaxRuleString.prototype.tryMatch = function (tokens) {
        return this.simpleTryMatchBoilerplate(tokens, function (token) {
            if (token.data.kind === 4 /* STRING */) {
                return {
                    data: token.data,
                    location: token.location,
                };
            }
            return undefined;
        });
    };
    SyntaxRuleString.prototype[Symbol.toStringTag] = function () {
        return token_1.formatTokenKind(4 /* STRING */);
    };
    return SyntaxRuleString;
}(SyntaxRule));
exports.SyntaxRuleString = SyntaxRuleString;
// SPECIFIC //
var SyntaxRuleNewline = /** @class */ (function (_super) {
    __extends(SyntaxRuleNewline, _super);
    function SyntaxRuleNewline() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SyntaxRuleNewline.prototype.tryMatch = function (tokens) {
        var originalFilter = tokens.tokenKindFilter[7 /* NEWLINE */];
        tokens.tokenKindFilter[7 /* NEWLINE */] = false;
        var result = this.simpleTryMatchBoilerplate(tokens, function (token) {
            if (token.data.kind === 7 /* NEWLINE */) {
                return {
                    data: token.data,
                    location: token.location,
                };
            }
            return undefined;
        });
        tokens.tokenKindFilter[7 /* NEWLINE */] = originalFilter;
        return result;
    };
    SyntaxRuleNewline.prototype[Symbol.toStringTag] = function () {
        return token_1.formatTokenKind(7 /* NEWLINE */);
    };
    return SyntaxRuleNewline;
}(SyntaxRule));
exports.SyntaxRuleNewline = SyntaxRuleNewline;
var SyntaxRuleJessie = /** @class */ (function (_super) {
    __extends(SyntaxRuleJessie, _super);
    function SyntaxRuleJessie(terminationTokens) {
        var _this = _super.call(this) || this;
        _this.terminationTokens = terminationTokens;
        return _this;
    }
    SyntaxRuleJessie.prototype.tryMatch = function (tokens) {
        return this.simpleTryMatchBoilerplate(tokens, function (token) {
            if (token.data.kind === 8 /* JESSIE_SCRIPT */) {
                return {
                    data: token.data,
                    location: token.location,
                };
            }
            return undefined;
        }, {
            type: 1 /* JESSIE_SCRIPT_EXPRESSION */,
            terminationTokens: this.terminationTokens,
        });
    };
    SyntaxRuleJessie.prototype[Symbol.toStringTag] = function () {
        return token_1.formatTokenKind(8 /* JESSIE_SCRIPT */);
    };
    return SyntaxRuleJessie;
}(SyntaxRule));
exports.SyntaxRuleJessie = SyntaxRuleJessie;
// COMBINATORS //
var SyntaxRuleOr = /** @class */ (function (_super) {
    __extends(SyntaxRuleOr, _super);
    function SyntaxRuleOr(first, second) {
        var _this = _super.call(this) || this;
        _this.first = first;
        _this.second = second;
        return _this;
    }
    SyntaxRuleOr.chainOr = function () {
        var rest = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            rest[_i] = arguments[_i];
        }
        if (rest.length === 0) {
            return new SyntaxRuleNever();
        }
        return rest.reduce(function (acc, curr) { return acc.or(curr); });
    };
    SyntaxRuleOr.prototype.tryMatch = function (tokens) {
        // Basic rules automatically restore `tokens` state on `nomatch`
        var firstMatch = this.first.tryMatch(tokens);
        if (firstMatch.kind === 'match') {
            return firstMatch;
        }
        var secondMatch = this.second.tryMatch(tokens);
        if (secondMatch.kind === 'match') {
            return __assign(__assign({}, secondMatch), { optionalAttempts: firstMatch.attempts.merge(secondMatch.optionalAttempts) });
        }
        return {
            kind: 'nomatch',
            attempts: firstMatch.attempts.merge(secondMatch.attempts),
        };
    };
    SyntaxRuleOr.prototype[Symbol.toStringTag] = function () {
        return this.first.toString() + ' or ' + this.second.toString();
    };
    return SyntaxRuleOr;
}(SyntaxRule));
exports.SyntaxRuleOr = SyntaxRuleOr;
/** Matches `first` followed by `second`.
 *
 * Use `.andFollowedBy` to chain additional `followedBy` rules to flatten the `match` tuple.
 */
var SyntaxRuleFollowedBy = /** @class */ (function (_super) {
    __extends(SyntaxRuleFollowedBy, _super);
    function SyntaxRuleFollowedBy(first, second) {
        var _this = _super.call(this) || this;
        _this.first = first;
        _this.second = second;
        return _this;
    }
    SyntaxRuleFollowedBy.prototype.andFollowedBy = function (rule) {
        return new SyntaxRuleFollowedBy(this, rule);
    };
    SyntaxRuleFollowedBy.prototype.tryMatch = function (tokens) {
        var save = tokens.save();
        var firstMatch = this.first.tryMatch(tokens);
        if (firstMatch.kind === 'nomatch') {
            tokens.rollback(save);
            return firstMatch;
        }
        var secondMatch = this.second.tryMatch(tokens);
        if (secondMatch.kind === 'nomatch') {
            tokens.rollback(save);
            return __assign(__assign({}, secondMatch), { attempts: secondMatch.attempts.merge(firstMatch.optionalAttempts) });
        }
        return {
            kind: 'match',
            match: __spreadArray(__spreadArray([], __read(firstMatch.match)), [secondMatch.match]),
            optionalAttempts: MatchAttempts.merge(firstMatch.optionalAttempts, secondMatch.optionalAttempts),
        };
    };
    SyntaxRuleFollowedBy.prototype[Symbol.toStringTag] = function () {
        return this.first.toString() + ' -> ' + this.second.toString();
    };
    return SyntaxRuleFollowedBy;
}(SyntaxRule));
exports.SyntaxRuleFollowedBy = SyntaxRuleFollowedBy;
/** Matches one or more occurences of `rule`. */
var SyntaxRuleRepeat = /** @class */ (function (_super) {
    __extends(SyntaxRuleRepeat, _super);
    function SyntaxRuleRepeat(rule) {
        var _this = _super.call(this) || this;
        _this.rule = rule;
        return _this;
    }
    SyntaxRuleRepeat.prototype.tryMatch = function (tokens) {
        var matches = [];
        var lastMatch;
        var lastResult;
        for (;;) {
            lastResult = this.rule.tryMatch(tokens);
            if (lastResult.kind === 'match') {
                lastMatch = lastResult;
                matches.push(lastMatch.match);
            }
            else {
                break;
            }
        }
        if (matches.length > 0) {
            return {
                kind: 'match',
                match: matches,
                optionalAttempts: lastResult.attempts.merge(lastMatch === null || lastMatch === void 0 ? void 0 : lastMatch.optionalAttempts),
            };
        }
        return lastResult;
    };
    SyntaxRuleRepeat.prototype[Symbol.toStringTag] = function () {
        return 'one or more ' + this.rule.toString();
    };
    return SyntaxRuleRepeat;
}(SyntaxRule));
exports.SyntaxRuleRepeat = SyntaxRuleRepeat;
/** Matches zero or one occurences of `rule`. */
var SyntaxRuleOptional = /** @class */ (function (_super) {
    __extends(SyntaxRuleOptional, _super);
    function SyntaxRuleOptional(rule) {
        var _this = _super.call(this) || this;
        _this.rule = rule;
        return _this;
    }
    SyntaxRuleOptional.prototype.tryMatch = function (tokens) {
        var match = this.rule.tryMatch(tokens);
        if (match.kind === 'match') {
            return match;
        }
        return {
            kind: 'match',
            match: undefined,
            optionalAttempts: match.attempts,
        };
    };
    SyntaxRuleOptional.prototype[Symbol.toStringTag] = function () {
        return 'optional ' + this.rule.toString();
    };
    return SyntaxRuleOptional;
}(SyntaxRule));
exports.SyntaxRuleOptional = SyntaxRuleOptional;
// META //
/** Matches rule and then restores `tokens` state. */
var SyntaxRuleLookahead = /** @class */ (function (_super) {
    __extends(SyntaxRuleLookahead, _super);
    function SyntaxRuleLookahead(rule, invert) {
        var _this = _super.call(this) || this;
        _this.rule = rule;
        _this.invert = invert !== null && invert !== void 0 ? invert : false;
        return _this;
    }
    SyntaxRuleLookahead.prototype.tryMatch = function (tokens) {
        var save = tokens.save();
        var result = this.rule.tryMatch(tokens);
        tokens.rollback(save);
        // Handle inversion
        if (this.invert) {
            if (result.kind === 'nomatch') {
                return {
                    kind: 'match',
                    match: undefined,
                };
            }
            else {
                return {
                    kind: 'nomatch',
                    attempts: new MatchAttempts(tokens.peek().value, [this]),
                };
            }
        }
        if (result.kind === 'match') {
            return __assign(__assign({}, result), { match: undefined });
        }
        return result;
    };
    SyntaxRuleLookahead.prototype[Symbol.toStringTag] = function () {
        return (this.invert ? 'not ' : '') + this.rule.toString();
    };
    return SyntaxRuleLookahead;
}(SyntaxRule));
exports.SyntaxRuleLookahead = SyntaxRuleLookahead;
// CUSTOM LOGIC //
/** Maps `match` value on success. */
var SyntaxRuleMap = /** @class */ (function (_super) {
    __extends(SyntaxRuleMap, _super);
    function SyntaxRuleMap(rule, mapper) {
        var _this = _super.call(this) || this;
        _this.rule = rule;
        _this.mapper = mapper;
        return _this;
    }
    SyntaxRuleMap.prototype.tryMatch = function (tokens) {
        var match = this.rule.tryMatch(tokens);
        if (match.kind === 'match') {
            return __assign(__assign({}, match), { match: this.mapper(match.match) });
        }
        return match;
    };
    SyntaxRuleMap.prototype[Symbol.toStringTag] = function () {
        return this.rule.toString();
    };
    return SyntaxRuleMap;
}(SyntaxRule));
exports.SyntaxRuleMap = SyntaxRuleMap;
var SyntaxRuleAndThen = /** @class */ (function (_super) {
    __extends(SyntaxRuleAndThen, _super);
    function SyntaxRuleAndThen(rule, then, description) {
        var _this = _super.call(this) || this;
        _this.rule = rule;
        _this.then = then;
        _this.description = description;
        return _this;
    }
    SyntaxRuleAndThen.prototype.tryMatch = function (tokens) {
        var peek = tokens.peek().value;
        var match = this.rule.tryMatch(tokens);
        if (match.kind === 'match') {
            var then = this.then(match.match);
            if (then.kind == 'match') {
                return {
                    kind: 'match',
                    match: then.value,
                    optionalAttempts: match.optionalAttempts,
                };
            }
            else {
                return {
                    kind: 'nomatch',
                    attempts: new MatchAttempts(peek, [this]).merge(match.optionalAttempts),
                };
            }
        }
        return match;
    };
    SyntaxRuleAndThen.prototype[Symbol.toStringTag] = function () {
        var _a;
        return (_a = this.description) !== null && _a !== void 0 ? _a : this.rule.toString();
    };
    return SyntaxRuleAndThen;
}(SyntaxRule));
exports.SyntaxRuleAndThen = SyntaxRuleAndThen;
// OTHER //
/**
 * Mutable rule.
 *
 * Since the syntax tree node types are recursive, it follows that the rule definitions must be too.
 * However, there is no way to achieve constant recursiveness - e.g. mutability must be used.
 *
 * This rule provides the option to mutate the inner rule after the object has been created
 * to allow for this mutability. However, it should not be used outside the usecase.
 */
var SyntaxRuleMutable = /** @class */ (function (_super) {
    __extends(SyntaxRuleMutable, _super);
    function SyntaxRuleMutable(
    // NOT readonly
    rule) {
        var _this = _super.call(this) || this;
        _this.rule = rule;
        return _this;
    }
    SyntaxRuleMutable.prototype.tryMatch = function (tokens) {
        if (this.rule === undefined) {
            throw 'This method should never be called before the mutable rule is initialized. This is an error in syntax rules definition.';
        }
        return this.rule.tryMatch(tokens);
    };
    SyntaxRuleMutable.prototype[Symbol.toStringTag] = function () {
        if (this.rule === undefined) {
            throw 'This method should never be called before the mutable rule is initialized. This is an error in syntax rules definition.';
        }
        return '[Mutable Rule]';
    };
    return SyntaxRuleMutable;
}(SyntaxRule));
exports.SyntaxRuleMutable = SyntaxRuleMutable;
/**
 * Never rules.
 *
 * This rule never matches.
 */
var SyntaxRuleNever = /** @class */ (function (_super) {
    __extends(SyntaxRuleNever, _super);
    function SyntaxRuleNever() {
        return _super.call(this) || this;
    }
    SyntaxRuleNever.prototype.tryMatch = function (_tokens) {
        return {
            kind: 'nomatch',
            attempts: new MatchAttempts(undefined, [this]),
        };
    };
    SyntaxRuleNever.prototype[Symbol.toStringTag] = function () {
        return '<NEVER>';
    };
    return SyntaxRuleNever;
}(SyntaxRule));
exports.SyntaxRuleNever = SyntaxRuleNever;
var SyntaxRuleDebugLog = /** @class */ (function (_super) {
    __extends(SyntaxRuleDebugLog, _super);
    function SyntaxRuleDebugLog(rule) {
        var _this = _super.call(this) || this;
        _this.rule = rule;
        return _this;
    }
    SyntaxRuleDebugLog.prototype.tryMatch = function (tokens) {
        var nextToken = tokens.peek();
        var result;
        try {
            result = this.rule.tryMatch(tokens);
        }
        catch (err) {
            console.debug('\nRule:', this.rule, '\nException:', err, '\nFirst token:', nextToken);
            throw err;
        }
        if (result.kind === 'nomatch') {
            console.debug('\nRule:', this.rule, '\nAttempts:', result.attempts, '\nFirst token:', nextToken);
        }
        else {
            console.debug('\nRule:', this.rule, '\nMatch:', result.match, '\nFirst token:', nextToken);
        }
        return result;
    };
    SyntaxRuleDebugLog.prototype[Symbol.toStringTag] = function () {
        return this.rule.toString();
    };
    return SyntaxRuleDebugLog;
}(SyntaxRule));
exports.SyntaxRuleDebugLog = SyntaxRuleDebugLog;
//# sourceMappingURL=rule.js.map