import { LexerContext } from '../lexer/context';
import { LexerTokenStream } from '../lexer/lexer';
import { IdentifierTokenData, IdentifierValue, JessieScriptTokenData, LexerToken, LexerTokenData, LiteralTokenData, NewlineTokenData, OperatorTokenData, OperatorValue, SeparatorTokenData, SeparatorValue, StringTokenData, TerminationTokens } from '../lexer/token';
import { LocationSpan } from '../source';
export declare class MatchAttempts {
    /** Token at which the rules failed */
    readonly token: LexerToken | undefined;
    /** Rules which failed at the token */
    readonly rules: readonly SyntaxRule<unknown>[];
    constructor(
    /** Token at which the rules failed */
    token: LexerToken | undefined, 
    /** Rules which failed at the token */
    rules: readonly SyntaxRule<unknown>[]);
    static merge(first: MatchAttempts | undefined, second: MatchAttempts | undefined): MatchAttempts | undefined;
    /** Merges two rule attempts according to the furthest token heuristic. */
    merge(other: MatchAttempts | undefined): MatchAttempts;
}
export declare type RuleResultMatch<T> = {
    kind: 'match';
    match: T;
    /** Optional and repeat rule propagate failures through this filed to report better errors. */
    optionalAttempts?: MatchAttempts;
};
export declare type RuleResultNoMatch = {
    kind: 'nomatch';
    attempts: MatchAttempts;
};
export declare type RuleResult<T> = RuleResultMatch<T> | RuleResultNoMatch;
export interface LexerTokenMatch<D extends LexerTokenData = LexerTokenData> {
    readonly data: D;
    readonly location: LocationSpan;
}
export declare abstract class SyntaxRule<T> {
    /**
     * Attempts to match rule to tokens.
     *
     * If the rule matches, matched tokens are transformed into a syntax tree node
     * in the `RuleResultMatch` object and consumed from the iterator.
     *
     * If the rule doesn't match `RuleResultNoMatch` is returned and no tokens are
     * consumed (iterator state is restored).
     */
    abstract tryMatch(tokens: LexerTokenStream): RuleResult<T>;
    protected simpleTryMatchBoilerplate(tokens: LexerTokenStream, predicate: (token: LexerToken) => T | undefined, context?: LexerContext): RuleResult<T>;
    toString(): string;
    abstract [Symbol.toStringTag](): string;
    static separator(separator?: SeparatorValue): SyntaxRuleSeparator;
    static operator(operator?: OperatorValue): SyntaxRuleOperator;
    static identifier(identifier?: IdentifierValue): SyntaxRuleIdentifier;
    static literal(): SyntaxRuleLiteral;
    static string(): SyntaxRuleString;
    static newline(): SyntaxRuleNewline;
    static jessie(terminatingChars?: ReadonlyArray<TerminationTokens>): SyntaxRuleJessie;
    or<R>(rule: SyntaxRule<R>): SyntaxRuleOr<T, R>;
    /**
     * To cascade multiple `followedBy` rules, use `.andFollowedBy` method on the
     * `SyntaxRuleFollowedBy` object that is returned to flatten nested tuples.
     */
    followedBy<R>(rule: SyntaxRule<R>): SyntaxRuleFollowedBy<[T], R>;
    map<M>(mapper: (_: T) => M): SyntaxRule<M>;
    andThen<M>(then: (_: T) => AndThenResult<M>, description?: string): SyntaxRule<M>;
    /** Ensures that `this` is followed by `rule` without consuming any tokens after `this`. */
    lookahead<R>(rule: SyntaxRule<R>): SyntaxRule<T>;
    /** Skips `rule` following `this` without affecting the returned type. */
    skip<R>(rule: SyntaxRule<R>): SyntaxRule<T>;
    /** Forgets `this` and expectes `rule` to follow. */
    forgetFollowedBy<R>(rule: SyntaxRule<R>): SyntaxRule<R>;
    static repeat<R>(rule: SyntaxRule<R>): SyntaxRuleRepeat<R>;
    static optional<R>(rule: SyntaxRule<R>): SyntaxRuleOptional<R>;
    /**
     * Returns `rule` that cannot be preceded by a newline.
     * Example usage: `SyntaxRule.identifier('slot').followedBy(SyntaxRule.sameLine(SyntaxRule.string()))`
     */
    static sameLine<R>(rule: SyntaxRule<R>): SyntaxRule<R>;
    debug(): SyntaxRule<T>;
}
export declare class SyntaxRuleSeparator extends SyntaxRule<LexerTokenMatch<SeparatorTokenData>> {
    readonly separator?: SeparatorValue | undefined;
    constructor(separator?: SeparatorValue | undefined);
    tryMatch(tokens: LexerTokenStream): RuleResult<LexerTokenMatch<SeparatorTokenData>>;
    [Symbol.toStringTag](): string;
}
export declare class SyntaxRuleOperator extends SyntaxRule<LexerTokenMatch<OperatorTokenData>> {
    readonly operator?: OperatorValue | undefined;
    constructor(operator?: OperatorValue | undefined);
    tryMatch(tokens: LexerTokenStream): RuleResult<LexerTokenMatch<OperatorTokenData>>;
    [Symbol.toStringTag](): string;
}
export declare class SyntaxRuleIdentifier extends SyntaxRule<LexerTokenMatch<IdentifierTokenData>> {
    readonly identifier?: string | undefined;
    constructor(identifier?: string | undefined);
    tryMatch(tokens: LexerTokenStream): RuleResult<LexerTokenMatch<IdentifierTokenData>>;
    [Symbol.toStringTag](): string;
}
export declare class SyntaxRuleLiteral extends SyntaxRule<LexerTokenMatch<LiteralTokenData>> {
    tryMatch(tokens: LexerTokenStream): RuleResult<LexerTokenMatch<LiteralTokenData>>;
    [Symbol.toStringTag](): string;
}
export declare class SyntaxRuleString extends SyntaxRule<LexerTokenMatch<StringTokenData>> {
    tryMatch(tokens: LexerTokenStream): RuleResult<LexerTokenMatch<StringTokenData>>;
    [Symbol.toStringTag](): string;
}
export declare class SyntaxRuleNewline extends SyntaxRule<LexerTokenMatch<NewlineTokenData>> {
    tryMatch(tokens: LexerTokenStream): RuleResult<LexerTokenMatch<NewlineTokenData>>;
    [Symbol.toStringTag](): string;
}
export declare class SyntaxRuleJessie extends SyntaxRule<LexerTokenMatch<JessieScriptTokenData>> {
    readonly terminationTokens?: readonly TerminationTokens[] | undefined;
    constructor(terminationTokens?: readonly TerminationTokens[] | undefined);
    tryMatch(tokens: LexerTokenStream): RuleResult<LexerTokenMatch<JessieScriptTokenData>>;
    [Symbol.toStringTag](): string;
}
export declare class SyntaxRuleOr<F, S> extends SyntaxRule<F | S> {
    readonly first: SyntaxRule<F>;
    readonly second: SyntaxRule<S>;
    constructor(first: SyntaxRule<F>, second: SyntaxRule<S>);
    static chainOr<R>(...rest: SyntaxRule<R>[]): SyntaxRule<R>;
    tryMatch(tokens: LexerTokenStream): RuleResult<F | S>;
    [Symbol.toStringTag](): string;
}
/** Matches `first` followed by `second`.
 *
 * Use `.andFollowedBy` to chain additional `followedBy` rules to flatten the `match` tuple.
 */
export declare class SyntaxRuleFollowedBy<F extends readonly unknown[], S> extends SyntaxRule<[...F, S]> {
    readonly first: SyntaxRule<F>;
    readonly second: SyntaxRule<S>;
    constructor(first: SyntaxRule<F>, second: SyntaxRule<S>);
    andFollowedBy<R>(rule: SyntaxRule<R>): SyntaxRuleFollowedBy<[...F, S], R>;
    tryMatch(tokens: LexerTokenStream): RuleResult<[...F, S]>;
    [Symbol.toStringTag](): string;
}
/** Matches one or more occurences of `rule`. */
export declare class SyntaxRuleRepeat<R> extends SyntaxRule<[R, ...R[]]> {
    readonly rule: SyntaxRule<R>;
    constructor(rule: SyntaxRule<R>);
    tryMatch(tokens: LexerTokenStream): RuleResult<[R, ...R[]]>;
    [Symbol.toStringTag](): string;
}
/** Matches zero or one occurences of `rule`. */
export declare class SyntaxRuleOptional<R> extends SyntaxRule<R | undefined> {
    readonly rule: SyntaxRule<R>;
    constructor(rule: SyntaxRule<R>);
    tryMatch(tokens: LexerTokenStream): RuleResultMatch<R | undefined>;
    [Symbol.toStringTag](): string;
}
/** Matches rule and then restores `tokens` state. */
export declare class SyntaxRuleLookahead<R> extends SyntaxRule<undefined> {
    readonly rule: SyntaxRule<R>;
    /**
     * Invert the lookahead, matching if the inner rule fails.
     */
    readonly invert: boolean;
    constructor(rule: SyntaxRule<R>, invert?: boolean);
    tryMatch(tokens: LexerTokenStream): RuleResult<undefined>;
    [Symbol.toStringTag](): string;
}
/** Maps `match` value on success. */
export declare class SyntaxRuleMap<R, M> extends SyntaxRule<M> {
    readonly rule: SyntaxRule<R>;
    readonly mapper: (_: R) => M;
    constructor(rule: SyntaxRule<R>, mapper: (_: R) => M);
    tryMatch(tokens: LexerTokenStream): RuleResult<M>;
    [Symbol.toStringTag](): string;
}
declare type AndThenResult<T> = {
    kind: 'match';
    value: T;
} | {
    kind: 'nomatch';
};
export declare class SyntaxRuleAndThen<R, M> extends SyntaxRule<M> {
    readonly rule: SyntaxRule<R>;
    readonly then: (_: R) => AndThenResult<M>;
    readonly description?: string | undefined;
    constructor(rule: SyntaxRule<R>, then: (_: R) => AndThenResult<M>, description?: string | undefined);
    tryMatch(tokens: LexerTokenStream): RuleResult<M>;
    [Symbol.toStringTag](): string;
}
/**
 * Mutable rule.
 *
 * Since the syntax tree node types are recursive, it follows that the rule definitions must be too.
 * However, there is no way to achieve constant recursiveness - e.g. mutability must be used.
 *
 * This rule provides the option to mutate the inner rule after the object has been created
 * to allow for this mutability. However, it should not be used outside the usecase.
 */
export declare class SyntaxRuleMutable<R> extends SyntaxRule<R> {
    rule?: SyntaxRule<R> | undefined;
    constructor(rule?: SyntaxRule<R> | undefined);
    tryMatch(tokens: LexerTokenStream): RuleResult<R>;
    [Symbol.toStringTag](): string;
}
/**
 * Never rules.
 *
 * This rule never matches.
 */
export declare class SyntaxRuleNever<R> extends SyntaxRule<R> {
    constructor();
    tryMatch(_tokens: LexerTokenStream): RuleResult<R>;
    [Symbol.toStringTag](): string;
}
export declare class SyntaxRuleDebugLog<R> extends SyntaxRule<R> {
    readonly rule: SyntaxRule<R>;
    constructor(rule: SyntaxRule<R>);
    tryMatch(tokens: LexerTokenStream): RuleResult<R>;
    [Symbol.toStringTag](): string;
}
export {};
