import { LexerTokenStream } from '../lexer';
import { RuleResult, SyntaxRule } from './rule';
export declare type ParserFeature = 'nested_object_literals' | 'shorthand_http_request_slots' | 'multiple_security_schemes';
export declare const PARSER_FEATURES: {
    [P in ParserFeature]: boolean;
};
export declare function isFeature(input: string): input is ParserFeature;
export declare function parseEnvFeatures(): void;
/**
 * Returns an array of all features.
 */
export declare function allFeatures(): ParserFeature[];
export declare class SyntaxRuleFeatureSubstitute<B, E> extends SyntaxRule<B | E> {
    readonly base: SyntaxRule<B>;
    readonly feature: ParserFeature;
    readonly enabled: SyntaxRule<E>;
    /** Remember the last execution feature state so we can correctly report it in errors even after features are toggled off. */
    private lastExecutionFeatureState;
    /**
     * If at runtime feature `feature` is enabled, acts as `enabled`, otherwise acts as `base`.
     */
    constructor(base: SyntaxRule<B>, feature: ParserFeature, enabled: SyntaxRule<E>);
    tryMatch(tokens: LexerTokenStream): RuleResult<B | E>;
    [Symbol.toStringTag](): string;
}
/**
 * Combined two rules using `or` if feature is enabled.
 */
export declare class SyntaxRuleFeatureOr<B, E> extends SyntaxRule<B | E> {
    readonly base: SyntaxRule<B>;
    readonly feature: ParserFeature;
    /** Remember the last execution feature state so we can correctly report it in errors even after features are toggled off. */
    private lastExecutionFeatureState;
    /** Precache the or rule so we don't construct it on each `tryMatch` and `toString` */
    private readonly orRule;
    /**
     * If at runtime feature `feature` is enabled, acts as `base.or(enabled)`, otherwise
     * acts as `base`.
     */
    constructor(base: SyntaxRule<B>, feature: ParserFeature, ...enabled: SyntaxRule<E>[]);
    tryMatch(tokens: LexerTokenStream): RuleResult<E | B>;
    [Symbol.toStringTag](): string;
}
