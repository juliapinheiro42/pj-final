"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PROFILE_DOCUMENT = exports.PROFILE_DOCUMENT_DEFINITION = exports.PROFILE_HEADER = exports.USECASE_DEFINITION = exports.NAMED_MODEL_DEFINITION = exports.NAMED_FIELD_DEFINITION = exports.FIELD_DEFINITION = exports.TYPE = exports.LIST_DEFINITION = exports.OBJECT_DEFINITION = exports.MODEL_TYPE_NAME = exports.ENUM_DEFINITION = exports.ENUM_VALUE = exports.PRIMITIVE_TYPE_NAME = void 0;
var parser_1 = require("../../../../common/document/parser");
var version_1 = require("../../../../common/document/version");
var metadata_1 = require("../../../../metadata");
var rule_1 = require("../../rule");
var common_1 = require("../common");
var literal_1 = require("./literal");
// MUTABLE RULES //
// These rules need to use mutability to achieve recursion and they make use of the `SyntaxRuleMutable` rule
var TYPE_MUT = new rule_1.SyntaxRuleMutable();
var FIELD_DEFINITION_MUT = new rule_1.SyntaxRuleMutable();
// TYPES //
/** From keywords: `boolean`, `number` and `string` */
exports.PRIMITIVE_TYPE_NAME = rule_1.SyntaxRule.identifier('boolean')
    .or(rule_1.SyntaxRule.identifier('number'))
    .or(rule_1.SyntaxRule.identifier('string'))
    .map(function (keywordMatch) {
    var name;
    switch (keywordMatch.data.identifier) {
        case 'number':
            name = 'number';
            break;
        case 'string':
            name = 'string';
            break;
        case 'boolean':
            name = 'boolean';
            break;
        default:
            throw 'Unexpected soft keyword. This is an error in the syntax rule definition';
    }
    return {
        kind: 'PrimitiveTypeName',
        name: name,
        location: keywordMatch.location,
    };
});
exports.ENUM_VALUE = common_1.documentedNode(common_1.expectTerminated(rule_1.SyntaxRule.identifier().followedBy(rule_1.SyntaxRule.optional(rule_1.SyntaxRule.operator('=').followedBy(rule_1.SyntaxRule.literal().or(rule_1.SyntaxRule.string())))), ',', '}', '\n').map(function (_a) {
    var _b = __read(_a, 2), name = _b[0], maybeAssignment = _b[1];
    var enumValue;
    if (maybeAssignment === undefined) {
        enumValue = name.data.identifier;
    }
    else {
        var match = maybeAssignment[1];
        switch (match.data.kind) {
            case 3 /* LITERAL */:
                enumValue = match.data.literal;
                break;
            case 4 /* STRING */:
                enumValue = match.data.string;
                break;
            default:
                throw new Error('Unexpected token kind. This is an error in the syntax rule definition');
        }
    }
    return {
        kind: 'EnumValue',
        value: enumValue,
        location: common_1.computeLocationSpan.apply(void 0, __spreadArray([name], __read((maybeAssignment !== null && maybeAssignment !== void 0 ? maybeAssignment : [])))),
    };
}));
/** Construct of form: `enum { values... }` */
exports.ENUM_DEFINITION = rule_1.SyntaxRule.identifier('enum')
    .followedBy(rule_1.SyntaxRule.separator('{'))
    .andFollowedBy(rule_1.SyntaxRule.repeat(exports.ENUM_VALUE))
    .andFollowedBy(rule_1.SyntaxRule.separator('}'))
    .map(function (_a) {
    var _b = __read(_a, 4), keyword = _b[0], _sepStart = _b[1], values = _b[2], sepEnd = _b[3];
    return {
        kind: 'EnumDefinition',
        values: values,
        location: common_1.computeLocationSpan(keyword, sepEnd),
    };
});
/** Name of a model type parsed from identifiers. */
exports.MODEL_TYPE_NAME = rule_1.SyntaxRule.identifier().map(function (name) {
    return {
        kind: 'ModelTypeName',
        name: name.data.identifier,
        location: common_1.computeLocationSpan(name),
    };
});
/** Construct of form: `{ fields... }` */
exports.OBJECT_DEFINITION = rule_1.SyntaxRule.separator('{')
    .followedBy(rule_1.SyntaxRule.optional(rule_1.SyntaxRule.repeat(FIELD_DEFINITION_MUT)))
    .andFollowedBy(rule_1.SyntaxRule.separator('}'))
    .map(function (_a) {
    var _b = __read(_a, 3), sepStart = _b[0], maybeFields = _b[1], sepEnd = _b[2];
    return {
        kind: 'ObjectDefinition',
        fields: maybeFields !== null && maybeFields !== void 0 ? maybeFields : [],
        location: common_1.computeLocationSpan(sepStart, sepEnd),
    };
});
// Helper rule to ensure correct precedence
//
// MODEL must go after both PRIMITIVE and ENUM
var BASIC_TYPE = exports.PRIMITIVE_TYPE_NAME.or(exports.ENUM_DEFINITION)
    .or(exports.MODEL_TYPE_NAME)
    .or(exports.OBJECT_DEFINITION);
/** Array type: `[type]` */
exports.LIST_DEFINITION = rule_1.SyntaxRule.separator('[')
    .followedBy(TYPE_MUT)
    .andFollowedBy(rule_1.SyntaxRule.separator(']'))
    .map(function (_a) {
    var _b = __read(_a, 3), sepStart = _b[0], type = _b[1], sepEnd = _b[2];
    return {
        kind: 'ListDefinition',
        elementType: type,
        location: common_1.computeLocationSpan(sepStart, sepEnd),
    };
});
var NON_UNION_TYPE = BASIC_TYPE.or(exports.LIST_DEFINITION)
    .followedBy(rule_1.SyntaxRule.optional(rule_1.SyntaxRule.operator('!')))
    .map(function (_a) {
    var _b = __read(_a, 2), type = _b[0], maybeOp = _b[1];
    if (maybeOp !== undefined) {
        return {
            kind: 'NonNullDefinition',
            type: type,
            location: common_1.computeLocationSpan(type, maybeOp),
        };
    }
    return type;
});
exports.TYPE = NON_UNION_TYPE.followedBy(rule_1.SyntaxRule.optional(rule_1.SyntaxRule.repeat(rule_1.SyntaxRule.operator('|').followedBy(NON_UNION_TYPE)))).map(function (_a) {
    var _b = __read(_a, 2), firstType = _b[0], maybeRestPairs = _b[1];
    // Handle unions
    if (maybeRestPairs !== undefined) {
        var types = __spreadArray([firstType], __read(maybeRestPairs.map(function (_a) {
            var _b = __read(_a, 2), _op = _b[0], type = _b[1];
            return type;
        })));
        return {
            kind: 'UnionDefinition',
            types: types,
            location: common_1.computeLocationSpan.apply(void 0, __spreadArray([firstType], __read(types))),
        };
    }
    return firstType;
});
TYPE_MUT.rule = exports.TYPE;
// FIELDS //
exports.FIELD_DEFINITION = common_1.documentedNode(common_1.expectTerminated(rule_1.SyntaxRule.identifier()
    .followedBy(rule_1.SyntaxRule.optional(rule_1.SyntaxRule.operator('!')))
    .andFollowedBy(rule_1.SyntaxRule.optional(rule_1.SyntaxRule.sameLine(exports.TYPE))), ',', '}', '\n').map(function (_a) {
    var _b = __read(_a, 3), name = _b[0], maybeRequired = _b[1], maybeType = _b[2];
    return {
        kind: 'FieldDefinition',
        fieldName: name.data.identifier,
        required: maybeRequired !== undefined,
        type: maybeType,
        location: common_1.computeLocationSpan(name, maybeRequired, maybeType),
    };
}));
FIELD_DEFINITION_MUT.rule = exports.FIELD_DEFINITION;
/** * Construct of form: `field ident type` or `field ident { fields... }` */
exports.NAMED_FIELD_DEFINITION = common_1.documentedNode(rule_1.SyntaxRule.identifier('field')
    .followedBy(rule_1.SyntaxRule.identifier())
    .andFollowedBy(rule_1.SyntaxRule.optional(rule_1.SyntaxRule.sameLine(exports.TYPE)))
    .map(function (_a) {
    var _b = __read(_a, 3), keyword = _b[0], fieldName = _b[1], maybeType = _b[2];
    return {
        kind: 'NamedFieldDefinition',
        fieldName: fieldName.data.identifier,
        type: maybeType,
        location: common_1.computeLocationSpan(keyword, fieldName, maybeType),
    };
}));
// MODEL //
/** Construct of form: `model ident type` or `model ident { fields... }` */
exports.NAMED_MODEL_DEFINITION = common_1.documentedNode(rule_1.SyntaxRule.identifier('model')
    .followedBy(rule_1.SyntaxRule.identifier())
    .andFollowedBy(rule_1.SyntaxRule.optional(rule_1.SyntaxRule.sameLine(exports.TYPE)))
    .map(function (_a) {
    var _b = __read(_a, 3), keyword = _b[0], modelName = _b[1], maybeType = _b[2];
    return {
        kind: 'NamedModelDefinition',
        modelName: modelName.data.identifier,
        type: maybeType,
        location: common_1.computeLocationSpan(keyword, modelName, maybeType),
    };
}));
function SLOT_FACTORY(names, rule) {
    var e_1, _a;
    var namesRule = rule_1.SyntaxRule.identifier(names[0]).map(function (v) { return [v]; });
    try {
        for (var _b = __values(names.slice(1)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var name = _c.value;
            namesRule = new rule_1.SyntaxRuleFollowedBy(namesRule, rule_1.SyntaxRule.sameLine(rule_1.SyntaxRule.identifier(name)));
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var slotrule = namesRule
        .followedBy(rule_1.SyntaxRule.sameLine(rule))
        .map(function (_a) {
        var _b = __read(_a, 2), names = _b[0], value = _b[1];
        return {
            value: value,
            location: common_1.computeLocationSpan.apply(void 0, __spreadArray(__spreadArray([], __read(names)), [value])),
        };
    });
    return common_1.documentedNode(slotrule);
}
function USECASE_SLOT_DEFINITION_FACTORY(names, rule) {
    return SLOT_FACTORY(names, rule).map(function (slot) {
        return {
            kind: 'UseCaseSlotDefinition',
            value: slot.value,
            location: slot.location,
            documentation: slot.documentation,
        };
    });
}
var USECASE_SAFETY = rule_1.SyntaxRule.identifier('safe')
    .or(rule_1.SyntaxRule.identifier('unsafe'))
    .or(rule_1.SyntaxRule.identifier('idempotent'));
var USECASE_EXAMPLE = rule_1.SyntaxRule.optional(rule_1.SyntaxRule.identifier())
    .followedBy(rule_1.SyntaxRule.separator('{'))
    .andFollowedBy(rule_1.SyntaxRule.optional(USECASE_SLOT_DEFINITION_FACTORY(['input'], literal_1.COMLINK_OBJECT_LITERAL)))
    .andFollowedBy(rule_1.SyntaxRule.optional(USECASE_SLOT_DEFINITION_FACTORY(['result'], literal_1.COMLINK_LITERAL)))
    .andFollowedBy(rule_1.SyntaxRule.optional(USECASE_SLOT_DEFINITION_FACTORY(['async', 'result'], literal_1.COMLINK_LITERAL)))
    .andFollowedBy(rule_1.SyntaxRule.optional(USECASE_SLOT_DEFINITION_FACTORY(['error'], literal_1.COMLINK_LITERAL)))
    .andFollowedBy(rule_1.SyntaxRule.separator('}'))
    .andThen(function (_a) {
    var _b = __read(_a, 7), maybeName = _b[0], sepStart = _b[1], maybeInput = _b[2], maybeResult = _b[3], maybeAsyncResult = _b[4], maybeError = _b[5], sepEnd = _b[6];
    if (maybeError !== undefined &&
        (maybeResult !== undefined || maybeAsyncResult !== undefined)) {
        return { kind: 'nomatch' };
    }
    var value = {
        kind: 'UseCaseExample',
        exampleName: maybeName === null || maybeName === void 0 ? void 0 : maybeName.data.identifier,
        input: maybeInput,
        result: maybeResult,
        asyncResult: maybeAsyncResult,
        error: maybeError,
        location: common_1.computeLocationSpan(maybeName, sepStart, sepEnd),
    };
    return { kind: 'match', value: value };
});
/**
* Construct of form:
```
usecase ident safety {
  input { fields... }
  result type
  error type
}
```
*/
exports.USECASE_DEFINITION = common_1.documentedNode(rule_1.SyntaxRule.identifier('usecase')
    .followedBy(rule_1.SyntaxRule.identifier(undefined))
    .andFollowedBy(rule_1.SyntaxRule.optional(USECASE_SAFETY))
    .andFollowedBy(rule_1.SyntaxRule.separator('{'))
    .andFollowedBy(rule_1.SyntaxRule.optional(USECASE_SLOT_DEFINITION_FACTORY(['input'], exports.OBJECT_DEFINITION)))
    .andFollowedBy(rule_1.SyntaxRule.optional(USECASE_SLOT_DEFINITION_FACTORY(['result'], exports.TYPE)))
    .andFollowedBy(rule_1.SyntaxRule.optional(USECASE_SLOT_DEFINITION_FACTORY(['async', 'result'], exports.TYPE)))
    .andFollowedBy(rule_1.SyntaxRule.optional(USECASE_SLOT_DEFINITION_FACTORY(['error'], exports.TYPE)))
    .andFollowedBy(rule_1.SyntaxRule.optional(rule_1.SyntaxRule.repeat(USECASE_SLOT_DEFINITION_FACTORY(['example'], USECASE_EXAMPLE))))
    .andFollowedBy(rule_1.SyntaxRule.separator('}'))
    .map(function (_a) {
    var _b = __read(_a, 10), keyword = _b[0], name = _b[1], maybeSafety = _b[2], _sepStart = _b[3], maybeInput = _b[4], maybeResult = _b[5], maybeAsyncResult = _b[6], maybeError = _b[7], maybeExamples = _b[8], sepEnd = _b[9];
    var safety = undefined;
    switch (maybeSafety === null || maybeSafety === void 0 ? void 0 : maybeSafety.data.identifier) {
        case undefined:
            break;
        case 'safe':
            safety = 'safe';
            break;
        case 'unsafe':
            safety = 'unsafe';
            break;
        case 'idempotent':
            safety = 'idempotent';
            break;
        default:
            throw 'Unexpected soft keyword. This is an error in the syntax rule definition';
    }
    return {
        kind: 'UseCaseDefinition',
        useCaseName: name.data.identifier,
        safety: safety,
        input: maybeInput,
        result: maybeResult,
        asyncResult: maybeAsyncResult,
        error: maybeError,
        examples: maybeExamples,
        location: common_1.computeLocationSpan(keyword, sepEnd),
    };
}));
// DOCUMENT //
var PROFILE_NAME = rule_1.SyntaxRule.identifier('name')
    .followedBy(rule_1.SyntaxRuleSeparator.operator('='))
    .andFollowedBy(rule_1.SyntaxRule.string().andThen(function (name) {
    var parseNameResult = parser_1.parseDocumentId(name.data.string);
    // profiles can't have version specified in the name
    if (parseNameResult.kind !== 'parsed' ||
        parseNameResult.value.middle.length !== 1 ||
        parseNameResult.value.version !== undefined) {
        return {
            kind: 'nomatch',
        };
    }
    var parsedName = parseNameResult.value;
    return {
        kind: 'match',
        value: {
            scope: parsedName.scope,
            name: parsedName.middle[0],
            location: name.location,
        },
    };
}, 'profile name in format `[<scope>/]<name>` with lowercase identifier'))
    .map(function (_a) {
    var _b = __read(_a, 3), keyword = _b[0], op = _b[1], name = _b[2];
    return {
        scope: name.scope,
        name: name.name,
        location: common_1.computeLocationSpan(keyword, op, name),
    };
});
var PROFILE_VERSION = rule_1.SyntaxRule.identifier('version')
    .followedBy(rule_1.SyntaxRuleSeparator.operator('='))
    .andFollowedBy(rule_1.SyntaxRule.string().andThen(function (version) {
    var _a, _b;
    try {
        var parsedVersion = version_1.VersionRange.fromString(version.data.string);
        return {
            kind: 'match',
            value: {
                major: parsedVersion.major,
                minor: (_a = parsedVersion.minor) !== null && _a !== void 0 ? _a : 0,
                patch: (_b = parsedVersion.patch) !== null && _b !== void 0 ? _b : 0,
                label: parsedVersion.label,
                location: version.location,
            },
        };
    }
    catch (error) {
        return { kind: 'nomatch' };
    }
}, 'semver version'))
    .map(function (_a) {
    var _b = __read(_a, 3), keyword = _b[0], op = _b[1], version = _b[2];
    return {
        version: {
            major: version.major,
            minor: version.minor,
            patch: version.patch,
        },
        location: common_1.computeLocationSpan(keyword, op, version),
    };
});
exports.PROFILE_HEADER = common_1.documentedNode(PROFILE_NAME.followedBy(PROFILE_VERSION).map(function (_a) {
    var _b = __read(_a, 2), name = _b[0], version = _b[1];
    return {
        kind: 'ProfileHeader',
        scope: name.scope,
        name: name.name,
        version: version.version,
        location: common_1.computeLocationSpan(name, version),
    };
}));
exports.PROFILE_DOCUMENT_DEFINITION = exports.USECASE_DEFINITION.or(exports.NAMED_FIELD_DEFINITION).or(exports.NAMED_MODEL_DEFINITION);
exports.PROFILE_DOCUMENT = rule_1.SyntaxRule.separator('SOF')
    .followedBy(exports.PROFILE_HEADER)
    .andFollowedBy(rule_1.SyntaxRule.optional(rule_1.SyntaxRule.repeat(exports.PROFILE_DOCUMENT_DEFINITION)))
    .andFollowedBy(rule_1.SyntaxRule.separator('EOF'))
    .andFollowedBy(new common_1.SyntaxRuleSourceChecksum())
    .map(function (_a) {
    var _b = __read(_a, 5), _SOF = _b[0], header = _b[1], maybeDefinitions = _b[2], _EOF = _b[3], sourceChecksum = _b[4];
    var definitions = maybeDefinitions !== null && maybeDefinitions !== void 0 ? maybeDefinitions : [];
    return {
        kind: 'ProfileDocument',
        header: header,
        definitions: definitions,
        location: common_1.computeLocationSpan.apply(void 0, __spreadArray([header], __read(definitions))),
        astMetadata: {
            astVersion: metadata_1.PARSED_AST_VERSION,
            parserVersion: metadata_1.PARSED_VERSION,
            sourceChecksum: sourceChecksum,
        },
    };
});
//# sourceMappingURL=profile.js.map