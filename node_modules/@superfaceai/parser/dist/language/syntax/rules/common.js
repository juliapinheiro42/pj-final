"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SyntaxRuleSourceChecksum = exports.expectTerminated = exports.TERMINATOR_TOKEN_FACTORY = exports.ASSIGNMENT_PATH_KEY = exports.mapAssignmentPath = exports.documentedNode = exports.computeLocationSpan = void 0;
var rule_1 = require("../rule");
var util_1 = require("../util");
function computeLocationSpan() {
    var _a, _b;
    var nodes = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        nodes[_i] = arguments[_i];
    }
    var first = (_a = nodes.find(function (node) { return node !== undefined; })) === null || _a === void 0 ? void 0 : _a.location;
    var last = (_b = nodes.reverse().find(function (node) { return node !== undefined; })) === null || _b === void 0 ? void 0 : _b.location;
    if (first === undefined || last === undefined) {
        return undefined;
    }
    return {
        start: {
            line: first.start.line,
            column: first.start.column,
            charIndex: first.start.charIndex,
        },
        end: {
            line: last.end.line,
            column: last.end.column,
            charIndex: last.end.charIndex,
        },
    };
}
exports.computeLocationSpan = computeLocationSpan;
function documentedNode(rule) {
    return rule_1.SyntaxRule.optional(rule_1.SyntaxRule.string())
        .followedBy(rule)
        .map(function (_a) {
        var _b = __read(_a, 2), maybeDoc = _b[0], result = _b[1];
        var doc = util_1.extractDocumentation(maybeDoc === null || maybeDoc === void 0 ? void 0 : maybeDoc.data.string);
        if (maybeDoc !== undefined && doc !== undefined) {
            result.documentation = {
                title: doc.title,
                description: doc.description,
                location: maybeDoc.location,
            };
        }
        return result;
    });
}
exports.documentedNode = documentedNode;
/**
 * Maps token match array into a string array of the assignment keys.
 */
function mapAssignmentPath(path) {
    if (path.length === 0) {
        throw new Error('Expected at least one element in the assignment path. This in an error in the rule definition.');
    }
    return path.map(function (p) {
        if (p.data.kind === 4 /* STRING */) {
            return p.data.string;
        }
        else {
            return p.data.identifier;
        }
    });
}
exports.mapAssignmentPath = mapAssignmentPath;
var ASSIGNMENT_KEY = rule_1.SyntaxRule.identifier().or(rule_1.SyntaxRule.string());
exports.ASSIGNMENT_PATH_KEY = ASSIGNMENT_KEY.followedBy(rule_1.SyntaxRule.optional(rule_1.SyntaxRule.repeat(rule_1.SyntaxRule.operator('.').followedBy(ASSIGNMENT_KEY)))).map(function (_a) {
    var _b = __read(_a, 2), first = _b[0], maybeRest = _b[1];
    var result = [first];
    if (maybeRest !== undefined) {
        maybeRest.forEach(function (_a) {
            var _b = __read(_a, 2), _op = _b[0], key = _b[1];
            return result.push(key);
        });
    }
    return result;
});
var TERMINATOR_TOKENS = {
    ')': rule_1.SyntaxRule.separator(')'),
    ']': rule_1.SyntaxRule.separator(']'),
    '}': rule_1.SyntaxRule.separator('}'),
    ',': rule_1.SyntaxRule.operator(','),
    ';': rule_1.SyntaxRule.operator(';'),
    '\n': rule_1.SyntaxRule.newline(),
};
function TERMINATOR_TOKEN_FACTORY() {
    var terminators = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        terminators[_i] = arguments[_i];
    }
    var rules = terminators.map(function (ter) { return TERMINATOR_TOKENS[ter]; });
    return rule_1.SyntaxRuleOr.chainOr.apply(rule_1.SyntaxRuleOr, __spreadArray([], __read(rules)));
}
exports.TERMINATOR_TOKEN_FACTORY = TERMINATOR_TOKEN_FACTORY;
/** Utility rule builder which expects the rule to be terminated and the optionally skips `,` or `;` */
function expectTerminated(rule) {
    var terminators = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        terminators[_i - 1] = arguments[_i];
    }
    return rule
        .lookahead(TERMINATOR_TOKEN_FACTORY.apply(void 0, __spreadArray([], __read(terminators))))
        .skip(rule_1.SyntaxRule.optional(TERMINATOR_TOKEN_FACTORY.apply(void 0, __spreadArray([], __read(terminators.filter(function (ter) { return ter === ',' || ter === ';'; }))))));
}
exports.expectTerminated = expectTerminated;
// CHECKSUM //
var SyntaxRuleSourceChecksum = /** @class */ (function (_super) {
    __extends(SyntaxRuleSourceChecksum, _super);
    function SyntaxRuleSourceChecksum() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SyntaxRuleSourceChecksum.prototype.tryMatch = function (tokens) {
        return {
            kind: 'match',
            match: tokens.source.checksum(),
        };
    };
    SyntaxRuleSourceChecksum.prototype[Symbol.toStringTag] = function () {
        return '<CHECKSUM>';
    };
    return SyntaxRuleSourceChecksum;
}(rule_1.SyntaxRule));
exports.SyntaxRuleSourceChecksum = SyntaxRuleSourceChecksum;
//# sourceMappingURL=common.js.map