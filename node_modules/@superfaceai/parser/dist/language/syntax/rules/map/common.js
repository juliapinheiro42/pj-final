"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MAYBE_CONTENT_TYPE = exports.MAP_HEADER = exports.MAP_VARIANT = exports.ITERATION_ATOM = exports.CONDITION_ATOM = exports.JESSIE_EXPRESSION_FACTORY = exports.PRIMITIVE_LITERAL = void 0;
var ast_1 = require("@superfaceai/ast");
var parser_1 = require("../../../../common/document/parser");
var rule_1 = require("../../rule");
var common_1 = require("../common");
exports.PRIMITIVE_LITERAL = rule_1.SyntaxRule.literal()
    .or(rule_1.SyntaxRule.string())
    .map(function (match) {
    var value = match.data.kind === 3 /* LITERAL */
        ? match.data.literal
        : match.data.string;
    return {
        kind: 'PrimitiveLiteral',
        value: value,
        location: match.location,
    };
});
function JESSIE_EXPRESSION_FACTORY() {
    var terminators = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        terminators[_i] = arguments[_i];
    }
    return rule_1.SyntaxRule.jessie(terminators).map(function (expression) {
        return {
            kind: 'JessieExpression',
            expression: expression.data.script,
            source: expression.data.sourceScript,
            sourceMap: expression.data.sourceMap,
            location: expression.location,
        };
    });
}
exports.JESSIE_EXPRESSION_FACTORY = JESSIE_EXPRESSION_FACTORY;
/**
 * if (<jessie>)
 */
exports.CONDITION_ATOM = rule_1.SyntaxRule.identifier('if')
    .followedBy(rule_1.SyntaxRule.separator('('))
    .andFollowedBy(JESSIE_EXPRESSION_FACTORY(')'))
    .andFollowedBy(rule_1.SyntaxRule.separator(')'))
    .map(function (_a) {
    var _b = __read(_a, 4), keyword = _b[0], _sepStart = _b[1], expression = _b[2], sepEnd = _b[3];
    return {
        kind: 'ConditionAtom',
        expression: expression,
        location: common_1.computeLocationSpan(keyword, sepEnd),
    };
});
exports.ITERATION_ATOM = rule_1.SyntaxRule.identifier('foreach')
    .followedBy(rule_1.SyntaxRule.separator('('))
    .andFollowedBy(rule_1.SyntaxRule.identifier())
    .andFollowedBy(rule_1.SyntaxRule.identifier('of'))
    .andFollowedBy(JESSIE_EXPRESSION_FACTORY(')'))
    .andFollowedBy(rule_1.SyntaxRule.separator(')'))
    .map(function (_a) {
    var _b = __read(_a, 6), keyword = _b[0], _sepStart = _b[1], iterationVariable = _b[2], _ofKEy = _b[3], iterable = _b[4], sepEnd = _b[5];
    return {
        kind: 'IterationAtom',
        iterationVariable: iterationVariable.data.identifier,
        iterable: iterable,
        location: common_1.computeLocationSpan(keyword, sepEnd),
    };
});
var PROFILE_ID = rule_1.SyntaxRule.identifier('profile')
    .followedBy(rule_1.SyntaxRuleSeparator.operator('='))
    .andFollowedBy(rule_1.SyntaxRule.string().andThen(function (id) {
    var parseIdResult = parser_1.parseProfileId(id.data.string);
    // must link to a profile
    if (parseIdResult.kind !== 'parsed') {
        return {
            kind: 'nomatch',
        };
    }
    var parsedId = parseIdResult.value;
    return {
        kind: 'match',
        value: {
            scope: parsedId.scope,
            name: parsedId.name,
            version: parsedId.version,
            location: id.location,
        },
    };
}, 'profile id in format `[<scope>/]<name>@<semver>` with lowercase identifiers'))
    .map(function (_a) {
    var _b = __read(_a, 3), keyword = _b[0], _op = _b[1], id = _b[2];
    return {
        scope: id.scope,
        name: id.name,
        version: id.version,
        location: common_1.computeLocationSpan(keyword, id),
    };
});
var PROVIDER_ID = rule_1.SyntaxRule.identifier('provider')
    .followedBy(rule_1.SyntaxRuleSeparator.operator('='))
    .andFollowedBy(rule_1.SyntaxRule.string().andThen(function (provider) {
    if (!ast_1.isValidDocumentName(provider.data.string)) {
        return {
            kind: 'nomatch',
        };
    }
    return {
        kind: 'match',
        value: {
            provider: provider.data.string,
            location: provider.location,
        },
    };
}, 'lowercase identifier'))
    .map(function (_a) {
    var _b = __read(_a, 3), keyword = _b[0], _op = _b[1], provider = _b[2];
    return {
        provider: provider.provider,
        location: common_1.computeLocationSpan(keyword, provider),
    };
});
exports.MAP_VARIANT = rule_1.SyntaxRule.identifier('variant')
    .followedBy(rule_1.SyntaxRuleSeparator.operator('='))
    .andFollowedBy(rule_1.SyntaxRule.string().andThen(function (variant) {
    if (!ast_1.isValidDocumentName(variant.data.string)) {
        return {
            kind: 'nomatch',
        };
    }
    return {
        kind: 'match',
        value: variant,
    };
}, 'lowercase identifier'))
    .map(function (_a) {
    var _b = __read(_a, 3), keyword = _b[0], _op = _b[1], variant = _b[2];
    return {
        variant: variant.data.string,
        location: common_1.computeLocationSpan(keyword, variant),
    };
});
exports.MAP_HEADER = common_1.documentedNode(PROFILE_ID.followedBy(PROVIDER_ID)
    .andFollowedBy(rule_1.SyntaxRule.optional(exports.MAP_VARIANT))
    .map(function (_a) {
    var _b, _c;
    var _d = __read(_a, 3), profile = _d[0], provider = _d[1], maybeVariant = _d[2];
    return {
        kind: 'MapHeader',
        profile: {
            scope: profile.scope,
            name: profile.name,
            // TODO: should we default to zeros here?
            version: {
                major: profile.version.major,
                minor: (_b = profile.version.minor) !== null && _b !== void 0 ? _b : 0,
                patch: (_c = profile.version.patch) !== null && _c !== void 0 ? _c : 0,
            },
        },
        provider: provider.provider,
        variant: maybeVariant === null || maybeVariant === void 0 ? void 0 : maybeVariant.variant,
        location: common_1.computeLocationSpan(profile, provider, maybeVariant),
    };
}));
/**
 * Content type with `*` placeholder handling.
 */
exports.MAYBE_CONTENT_TYPE = rule_1.SyntaxRule.optional(rule_1.SyntaxRule.string().map(function (match) {
    if (match.data.string === '*') {
        return undefined;
    }
    else {
        return match.data.string;
    }
}));
//# sourceMappingURL=common.js.map