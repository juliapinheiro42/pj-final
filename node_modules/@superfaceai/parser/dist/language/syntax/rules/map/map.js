"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MAP_DOCUMENT = exports.MAP_DOCUMENT_DEFINITION = exports.OPERATION_DEFINITION = exports.MAP_DEFINITION = exports.OPERATION_SUBSTATEMENT = exports.MAP_SUBSTATEMENT = exports.OPERATION_OUTCOME_STATEMENT = exports.MAP_OUTCOME_STATEMENT = exports.HTTP_CALL_STATEMENT_FACTORY = exports.HTTP_CALL_STATEMENT_REQUEST = exports.HTTP_REQUEST_VARIABLES_SHORTHAND = exports.HTTP_REQUEST_VARIABLES_BLOCK = exports.CALL_STATEMENT_FACTORY = exports.SET_STATEMENT = exports.SET_BLOCK_ASSIGNMENT = exports.OBJECT_LITERAL = exports.OBJECT_LITERAL_ASSIGNMENT = exports.INLINE_CALL = exports.ARGUMENT_LIST_ASSIGNMENT = void 0;
var metadata_1 = require("../../../../metadata");
var features_1 = require("../../features");
var rule_1 = require("../../rule");
var common_1 = require("../common");
var common_2 = require("./common");
// ASSIGNMENTS //
/**
 * Factory for matching rhs expressions (after '=').
 */
function RHS_EXPRESSION_FACTORY(nonJessieAttempt) {
    var terminators = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        terminators[_i - 1] = arguments[_i];
    }
    return nonJessieAttempt
        .lookahead(common_1.TERMINATOR_TOKEN_FACTORY.apply(void 0, __spreadArray([], __read(terminators))))
        .or(common_2.JESSIE_EXPRESSION_FACTORY.apply(void 0, __spreadArray([], __read(terminators))))
        .skip(rule_1.SyntaxRule.optional(common_1.TERMINATOR_TOKEN_FACTORY.apply(void 0, __spreadArray([], __read(terminators.filter(function (ter) { return ter === ',' || ter === ';'; }))))));
}
function ASSIGNMENT_FACTORY(rhs) {
    return common_1.ASSIGNMENT_PATH_KEY.followedBy(rhs).map(function (_a) {
        var _b = __read(_a, 2), path = _b[0], value = _b[1];
        return {
            kind: 'Assignment',
            key: common_1.mapAssignmentPath(path),
            value: value,
            location: common_1.computeLocationSpan.apply(void 0, __spreadArray(__spreadArray([], __read(path)), [value])),
        };
    });
}
exports.ARGUMENT_LIST_ASSIGNMENT = ASSIGNMENT_FACTORY(rule_1.SyntaxRule.operator('=').forgetFollowedBy(RHS_EXPRESSION_FACTORY(common_2.PRIMITIVE_LITERAL, ',', ')')));
var CALL_STATEMENT_HEAD = rule_1.SyntaxRule.identifier('call')
    .followedBy(rule_1.SyntaxRule.optional(common_2.ITERATION_ATOM))
    .andFollowedBy(rule_1.SyntaxRule.identifier())
    .andFollowedBy(rule_1.SyntaxRule.separator('('))
    .andFollowedBy(rule_1.SyntaxRule.optional(rule_1.SyntaxRule.repeat(exports.ARGUMENT_LIST_ASSIGNMENT)))
    .andFollowedBy(rule_1.SyntaxRule.separator(')'))
    .andFollowedBy(rule_1.SyntaxRule.optional(common_2.CONDITION_ATOM))
    .map(function (_a) {
    var _b = __read(_a, 7), key = _b[0], maybeIteration = _b[1], name = _b[2], _sepStart = _b[3], maybeArguments = _b[4], sepEnd = _b[5], maybeCondition = _b[6];
    return {
        iteration: maybeIteration,
        condition: maybeCondition,
        operationName: name.data.identifier,
        arguments: maybeArguments !== null && maybeArguments !== void 0 ? maybeArguments : [],
        location: common_1.computeLocationSpan(key, sepEnd, maybeCondition),
    };
});
exports.INLINE_CALL = CALL_STATEMENT_HEAD.map(function (head) {
    return __assign({ kind: 'InlineCall' }, head);
});
// ATOMS //
var OBJECT_LITERAL_MUT = new rule_1.SyntaxRuleMutable();
exports.OBJECT_LITERAL_ASSIGNMENT = ASSIGNMENT_FACTORY(new features_1.SyntaxRuleFeatureOr(rule_1.SyntaxRule.operator('=').forgetFollowedBy(RHS_EXPRESSION_FACTORY(exports.INLINE_CALL.or(common_2.PRIMITIVE_LITERAL), '\n', ',', '}')), 'nested_object_literals', common_1.expectTerminated(OBJECT_LITERAL_MUT, '\n', ',', '}')));
exports.OBJECT_LITERAL = rule_1.SyntaxRule.separator('{')
    .followedBy(rule_1.SyntaxRule.optional(rule_1.SyntaxRule.repeat(exports.OBJECT_LITERAL_ASSIGNMENT)))
    .andFollowedBy(rule_1.SyntaxRule.separator('}'))
    .map(function (_a) {
    var _b = __read(_a, 3), sepStart = _b[0], maybeFields = _b[1], sepEnd = _b[2];
    return {
        kind: 'ObjectLiteral',
        fields: maybeFields !== null && maybeFields !== void 0 ? maybeFields : [],
        location: common_1.computeLocationSpan(sepStart, sepEnd),
    };
});
OBJECT_LITERAL_MUT.rule = exports.OBJECT_LITERAL;
exports.SET_BLOCK_ASSIGNMENT = ASSIGNMENT_FACTORY(new features_1.SyntaxRuleFeatureOr(rule_1.SyntaxRule.operator('=').forgetFollowedBy(RHS_EXPRESSION_FACTORY(exports.INLINE_CALL.or(common_2.PRIMITIVE_LITERAL), '\n', ';', '}')), 'nested_object_literals', common_1.expectTerminated(exports.OBJECT_LITERAL, '\n', ';', '}')));
// SET STATEMENTS //
/**
 * set <?condition> { <...assignment> }
 */
var SET_STATEMENT_FULL = rule_1.SyntaxRule.identifier('set')
    .followedBy(rule_1.SyntaxRule.optional(common_2.CONDITION_ATOM))
    .andFollowedBy(rule_1.SyntaxRule.separator('{'))
    .andFollowedBy(rule_1.SyntaxRule.repeat(exports.SET_BLOCK_ASSIGNMENT))
    .andFollowedBy(rule_1.SyntaxRule.separator('}'))
    .map(function (_a) {
    var _b = __read(_a, 5), keyword = _b[0], maybeCondition = _b[1], _sepStart = _b[2], assignments = _b[3], sepEnd = _b[4];
    return {
        kind: 'SetStatement',
        condition: maybeCondition,
        assignments: assignments,
        location: common_1.computeLocationSpan(keyword, sepEnd),
    };
});
var SET_STATEMENT_RAW = exports.SET_BLOCK_ASSIGNMENT.map(function (assignment) {
    return {
        kind: 'SetStatement',
        assignments: [assignment],
        location: assignment.location,
    };
});
exports.SET_STATEMENT = SET_STATEMENT_FULL.or(SET_STATEMENT_RAW);
// CALL STATEMENT //
/**
 * call name(<...arguments>) <?condition> { <...statements> }
 */
function CALL_STATEMENT_FACTORY(substatementRule) {
    return CALL_STATEMENT_HEAD.followedBy(rule_1.SyntaxRule.separator('{'))
        .andFollowedBy(rule_1.SyntaxRule.optional(rule_1.SyntaxRule.repeat(exports.SET_STATEMENT.or(substatementRule))))
        .andFollowedBy(rule_1.SyntaxRule.separator('}'))
        .map(function (_a) {
        var _b = __read(_a, 4), head = _b[0], _sepStart = _b[1], statements = _b[2], sepEnd = _b[3];
        return __assign(__assign({ kind: 'CallStatement' }, head), { statements: statements !== null && statements !== void 0 ? statements : [], location: common_1.computeLocationSpan(head, sepEnd) });
    });
}
exports.CALL_STATEMENT_FACTORY = CALL_STATEMENT_FACTORY;
var HTTP_CALL_STATEMENT_SECURITY_REQUIREMENT = rule_1.SyntaxRule.identifier('security')
    .followedBy(rule_1.SyntaxRule.string().or(rule_1.SyntaxRule.identifier('none')))
    .lookahead(rule_1.SyntaxRule.newline())
    .map(function (_a) {
    var _b = __read(_a, 2), keyword = _b[0], id = _b[1];
    var idString = undefined;
    if (id.data.kind === 4 /* STRING */) {
        idString = id.data.string;
    }
    return {
        id: idString,
        location: common_1.computeLocationSpan(keyword, id),
    };
});
var HTTP_CALL_STATEMENT_SECURITY_REQUIREMENTS = new features_1.SyntaxRuleFeatureSubstitute(HTTP_CALL_STATEMENT_SECURITY_REQUIREMENT.map(function (s) { return [s]; }), 'multiple_security_schemes', rule_1.SyntaxRule.repeat(HTTP_CALL_STATEMENT_SECURITY_REQUIREMENT)).map(function (arr) {
    var requirements = arr
        .filter(function (elem) { return elem.id !== undefined; })
        .map(function (req) {
        if (typeof req.id !== 'string') {
            // .filter API is.. lacking
            throw 'unreachable';
        }
        return {
            id: req.id,
            scheme: req.scheme,
        };
    });
    return {
        security: requirements,
        location: common_1.computeLocationSpan.apply(void 0, __spreadArray([], __read(arr))),
    };
});
var HTTP_CALL_STATEMENT_REQUEST_SLOT_LITERAL = rule_1.SyntaxRule.sameLine(exports.OBJECT_LITERAL).lookahead(common_1.TERMINATOR_TOKEN_FACTORY('\n', '}'));
var HTTP_CALL_STATEMENT_REQUEST_QUERY_SLOT = rule_1.SyntaxRule.identifier('query').followedBy(HTTP_CALL_STATEMENT_REQUEST_SLOT_LITERAL);
var HTTP_CALL_STATEMENT_REQUEST_HEADERS_SLOT = rule_1.SyntaxRule.identifier('headers').followedBy(HTTP_CALL_STATEMENT_REQUEST_SLOT_LITERAL);
var HTTP_CALL_STATEMENT_REQUEST_BODY_SLOT = rule_1.SyntaxRule.identifier('body').followedBy(HTTP_CALL_STATEMENT_REQUEST_SLOT_LITERAL.or(rule_1.SyntaxRule.operator('=').forgetFollowedBy(RHS_EXPRESSION_FACTORY(exports.INLINE_CALL.or(common_2.PRIMITIVE_LITERAL), '\n', '}'))));
exports.HTTP_REQUEST_VARIABLES_BLOCK = rule_1.SyntaxRule.separator('{')
    .followedBy(rule_1.SyntaxRule.optional(HTTP_CALL_STATEMENT_REQUEST_QUERY_SLOT))
    .andFollowedBy(rule_1.SyntaxRule.optional(HTTP_CALL_STATEMENT_REQUEST_HEADERS_SLOT))
    .andFollowedBy(rule_1.SyntaxRule.optional(HTTP_CALL_STATEMENT_REQUEST_BODY_SLOT))
    .andFollowedBy(rule_1.SyntaxRule.separator('}'))
    .map(function (_a) {
    var _b = __read(_a, 5), sepStart = _b[0], maybeQuery = _b[1], maybeHeaders = _b[2], maybeBody = _b[3], sepEnd = _b[4];
    return {
        query: maybeQuery === null || maybeQuery === void 0 ? void 0 : maybeQuery[1],
        headers: maybeHeaders === null || maybeHeaders === void 0 ? void 0 : maybeHeaders[1],
        body: maybeBody === null || maybeBody === void 0 ? void 0 : maybeBody[1],
        location: common_1.computeLocationSpan(sepStart, sepEnd),
    };
});
exports.HTTP_REQUEST_VARIABLES_SHORTHAND = rule_1.SyntaxRuleOr.chainOr(HTTP_CALL_STATEMENT_REQUEST_QUERY_SLOT.map(function (_a) {
    var _b = __read(_a, 2), _ = _b[0], value = _b[1];
    return {
        query: value,
        location: value.location,
    };
}), HTTP_CALL_STATEMENT_REQUEST_HEADERS_SLOT.map(function (_a) {
    var _b = __read(_a, 2), _ = _b[0], value = _b[1];
    return {
        headers: value,
        location: value.location,
    };
}), HTTP_CALL_STATEMENT_REQUEST_BODY_SLOT.map(function (_a) {
    var _b = __read(_a, 2), _ = _b[0], value = _b[1];
    return {
        body: value,
        location: value.location,
    };
}));
exports.HTTP_CALL_STATEMENT_REQUEST = rule_1.SyntaxRule.identifier('request')
    .followedBy(common_2.MAYBE_CONTENT_TYPE)
    .andFollowedBy(rule_1.SyntaxRule.optional(rule_1.SyntaxRule.string()) // content language
)
    .andFollowedBy(new features_1.SyntaxRuleFeatureOr(exports.HTTP_REQUEST_VARIABLES_BLOCK, 'shorthand_http_request_slots', exports.HTTP_REQUEST_VARIABLES_SHORTHAND))
    .map(function (_a) {
    var _b = __read(_a, 4), keyword = _b[0], maybeContentType = _b[1], maybeContentLanguage = _b[2], variablesBlock = _b[3];
    return {
        contentType: maybeContentType,
        contentLanguage: maybeContentLanguage === null || maybeContentLanguage === void 0 ? void 0 : maybeContentLanguage.data.string,
        query: variablesBlock.query,
        headers: variablesBlock.headers,
        body: variablesBlock.body,
        location: common_1.computeLocationSpan(keyword, variablesBlock),
    };
});
var HTTP_REQUEST_OPTIONAL = rule_1.SyntaxRule.optional(HTTP_CALL_STATEMENT_SECURITY_REQUIREMENTS)
    .followedBy(rule_1.SyntaxRule.optional(exports.HTTP_CALL_STATEMENT_REQUEST))
    .map(function (_a) {
    var _b = __read(_a, 2), maybeSecurity = _b[0], maybeRequest = _b[1];
    if (maybeSecurity !== undefined && maybeRequest !== undefined) {
        return __assign(__assign(__assign({ kind: 'HttpRequest' }, maybeRequest), maybeSecurity), { location: common_1.computeLocationSpan(maybeSecurity, maybeRequest) });
    }
    else if (maybeSecurity !== undefined) {
        return __assign({ kind: 'HttpRequest' }, maybeSecurity);
    }
    else if (maybeRequest !== undefined) {
        return __assign(__assign({ kind: 'HttpRequest' }, maybeRequest), { security: [] });
    }
    else {
        return undefined;
    }
});
function HTTP_CALL_STATEMENT_RESPONSE_HANDLER(substatementRule) {
    return rule_1.SyntaxRule.identifier('response')
        .followedBy(rule_1.SyntaxRule.optional(rule_1.SyntaxRule.literal().andThen(function (match) {
        return typeof match.data.literal === 'number'
            ? { kind: 'match', value: match.data.literal }
            : { kind: 'nomatch' };
    }, 'number literal')))
        .andFollowedBy(common_2.MAYBE_CONTENT_TYPE)
        .andFollowedBy(rule_1.SyntaxRule.optional(rule_1.SyntaxRule.string()) // content language
    )
        .andFollowedBy(rule_1.SyntaxRule.separator('{'))
        .andFollowedBy(rule_1.SyntaxRule.optional(rule_1.SyntaxRule.repeat(exports.SET_STATEMENT.or(substatementRule))))
        .andFollowedBy(rule_1.SyntaxRule.separator('}'))
        .map(function (_a) {
        var _b = __read(_a, 7), keyword = _b[0], maybeStatusCode = _b[1], maybeContentType = _b[2], maybeContentLanguage = _b[3], _sepStart = _b[4], maybeSubstatements = _b[5], sepEnd = _b[6];
        return {
            kind: 'HttpResponseHandler',
            statusCode: maybeStatusCode,
            contentType: maybeContentType,
            contentLanguage: maybeContentLanguage === null || maybeContentLanguage === void 0 ? void 0 : maybeContentLanguage.data.string,
            statements: maybeSubstatements !== null && maybeSubstatements !== void 0 ? maybeSubstatements : [],
            location: common_1.computeLocationSpan(keyword, sepEnd),
        };
    });
}
function HTTP_CALL_STATEMENT_FACTORY(substatementRule) {
    return rule_1.SyntaxRule.identifier('http')
        .followedBy(rule_1.SyntaxRule.identifier() // verb
    )
        .andFollowedBy(rule_1.SyntaxRule.string() // url
    )
        .andFollowedBy(rule_1.SyntaxRule.separator('{'))
        .andFollowedBy(HTTP_REQUEST_OPTIONAL)
        .andFollowedBy(rule_1.SyntaxRule.optional(rule_1.SyntaxRule.repeat(HTTP_CALL_STATEMENT_RESPONSE_HANDLER(substatementRule))))
        .andFollowedBy(rule_1.SyntaxRule.separator('}'))
        .map(function (_a) {
        var _b = __read(_a, 7), keyword = _b[0], verb = _b[1], url = _b[2], _sepStart = _b[3], maybeRequest = _b[4], maybeResponseHandlers = _b[5], sepEnd = _b[6];
        return {
            kind: 'HttpCallStatement',
            method: verb.data.identifier,
            url: url.data.string,
            request: maybeRequest,
            responseHandlers: maybeResponseHandlers !== null && maybeResponseHandlers !== void 0 ? maybeResponseHandlers : [],
            location: common_1.computeLocationSpan(keyword, sepEnd),
        };
    });
}
exports.HTTP_CALL_STATEMENT_FACTORY = HTTP_CALL_STATEMENT_FACTORY;
// CONTEXTUAL STATEMENTS //
var OUTCOME_VALUE = RHS_EXPRESSION_FACTORY(exports.OBJECT_LITERAL.or(common_2.PRIMITIVE_LITERAL), '\n', ';', '}');
/**
 * return? map result/error <?condition> <value>;
 */
exports.MAP_OUTCOME_STATEMENT = rule_1.SyntaxRule.optional(rule_1.SyntaxRule.identifier('return'))
    .followedBy(rule_1.SyntaxRule.identifier('map'))
    .andFollowedBy(rule_1.SyntaxRule.identifier('result').or(rule_1.SyntaxRule.identifier('error')))
    .andFollowedBy(rule_1.SyntaxRule.optional(common_2.CONDITION_ATOM))
    .andFollowedBy(OUTCOME_VALUE)
    .map(function (_a) {
    var _b = __read(_a, 5), maybeReturn = _b[0], keywordMap = _b[1], keywordType = _b[2], maybeCondition = _b[3], value = _b[4];
    return {
        kind: 'OutcomeStatement',
        isError: keywordType.data.identifier === 'error',
        terminateFlow: maybeReturn !== undefined,
        condition: maybeCondition,
        value: value,
        location: common_1.computeLocationSpan(maybeReturn, keywordMap, value),
    };
});
/**
 * return/fail <?condition> <value>;
 */
exports.OPERATION_OUTCOME_STATEMENT = rule_1.SyntaxRule.identifier('return')
    .or(rule_1.SyntaxRule.identifier('fail'))
    .followedBy(rule_1.SyntaxRule.optional(common_2.CONDITION_ATOM))
    .andFollowedBy(OUTCOME_VALUE)
    .map(function (_a) {
    var _b = __read(_a, 3), keywordType = _b[0], maybeCondition = _b[1], value = _b[2];
    return {
        kind: 'OutcomeStatement',
        isError: keywordType.data.identifier === 'fail',
        terminateFlow: true,
        condition: maybeCondition,
        value: value,
        location: common_1.computeLocationSpan(keywordType, value),
    };
});
function DEFINITION_SUBSTATEMENTS_FACTORY(substatements) {
    return substatements
        .or(CALL_STATEMENT_FACTORY(substatements))
        .or(HTTP_CALL_STATEMENT_FACTORY(substatements))
        .or(exports.SET_STATEMENT);
}
exports.MAP_SUBSTATEMENT = DEFINITION_SUBSTATEMENTS_FACTORY(exports.MAP_OUTCOME_STATEMENT);
exports.OPERATION_SUBSTATEMENT = DEFINITION_SUBSTATEMENTS_FACTORY(exports.OPERATION_OUTCOME_STATEMENT);
// MAP DEFINITION //
exports.MAP_DEFINITION = common_1.documentedNode(rule_1.SyntaxRule.identifier('map')
    .followedBy(rule_1.SyntaxRule.identifier())
    .andFollowedBy(rule_1.SyntaxRule.separator('{'))
    .andFollowedBy(rule_1.SyntaxRule.optional(rule_1.SyntaxRule.repeat(exports.MAP_SUBSTATEMENT)))
    .andFollowedBy(rule_1.SyntaxRule.separator('}'))
    .map(function (_a) {
    var _b = __read(_a, 5), keyword = _b[0], name = _b[1], _sepStart = _b[2], maybeStatements = _b[3], sepEnd = _b[4];
    return {
        kind: 'MapDefinition',
        name: name.data.identifier,
        usecaseName: name.data.identifier,
        statements: maybeStatements !== null && maybeStatements !== void 0 ? maybeStatements : [],
        location: common_1.computeLocationSpan(keyword, sepEnd),
    };
}));
// OPERATION DEFINITION //
exports.OPERATION_DEFINITION = common_1.documentedNode(rule_1.SyntaxRule.identifier('operation')
    .followedBy(rule_1.SyntaxRule.identifier())
    .andFollowedBy(rule_1.SyntaxRule.separator('{'))
    .andFollowedBy(rule_1.SyntaxRule.optional(rule_1.SyntaxRule.repeat(exports.OPERATION_SUBSTATEMENT)))
    .andFollowedBy(rule_1.SyntaxRule.separator('}'))
    .map(function (_a) {
    var _b = __read(_a, 5), keyword = _b[0], name = _b[1], _sepStart = _b[2], maybeStatements = _b[3], sepEnd = _b[4];
    return {
        kind: 'OperationDefinition',
        name: name.data.identifier,
        statements: maybeStatements !== null && maybeStatements !== void 0 ? maybeStatements : [],
        location: common_1.computeLocationSpan(keyword, sepEnd),
    };
}));
// DOCUMENT //
exports.MAP_DOCUMENT_DEFINITION = exports.MAP_DEFINITION.or(exports.OPERATION_DEFINITION);
exports.MAP_DOCUMENT = rule_1.SyntaxRule.separator('SOF')
    .followedBy(common_2.MAP_HEADER)
    .andFollowedBy(rule_1.SyntaxRule.optional(rule_1.SyntaxRule.repeat(exports.MAP_DOCUMENT_DEFINITION)))
    .andFollowedBy(rule_1.SyntaxRule.separator('EOF'))
    .andFollowedBy(new common_1.SyntaxRuleSourceChecksum())
    .map(function (_a) {
    var _b = __read(_a, 5), _SOF = _b[0], header = _b[1], maybeDefinitions = _b[2], _EOF = _b[3], sourceChecksum = _b[4];
    var definitions = maybeDefinitions !== null && maybeDefinitions !== void 0 ? maybeDefinitions : [];
    return {
        kind: 'MapDocument',
        header: header,
        definitions: definitions,
        location: common_1.computeLocationSpan.apply(void 0, __spreadArray([header], __read(definitions))),
        astMetadata: {
            astVersion: metadata_1.PARSED_AST_VERSION,
            parserVersion: metadata_1.PARSED_VERSION,
            sourceChecksum: sourceChecksum,
        },
    };
});
//# sourceMappingURL=map.js.map