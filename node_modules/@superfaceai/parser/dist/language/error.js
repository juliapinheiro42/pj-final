"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SyntaxError = void 0;
var token_1 = require("./lexer/token");
/**
 * Computes span and the initial line offset of a (up to) 3-line block that encompasses
 * the token at `innerLocation`.
 */
function computeVisualizeBlockSpan(body, innerLocation) {
    // Find start of the block slice, which is one line before the inner line, or from SOF
    var innerLineStart = innerLocation.start.charIndex - (innerLocation.start.column - 1);
    // Line offset is the offset between the innerLine index and the block start line index
    var lineOffset = 0;
    // This finds the last newline before the innerLine newline or -1
    var start = 0;
    if (innerLineStart !== 0) {
        start = body.slice(0, innerLineStart - 1).lastIndexOf('\n') + 1;
        lineOffset = -1;
    }
    // Find end of the vis block slice, which is one line after the inner line, or until EOF
    var end = body.length;
    var innerLineEnd = body.indexOf('\n', innerLocation.end.charIndex);
    if (innerLineEnd !== -1) {
        var nextLineEnd = body.indexOf('\n', innerLineEnd + 1);
        if (nextLineEnd !== -1) {
            end = nextLineEnd;
        }
    }
    return { start: start, end: end, lineOffset: lineOffset };
}
/**
 * Formats line prefix used in block visualization.
 *
 * Example: ` 13 | ` with `padSize = 3` and `lineNumber = 13`.
 */
function formatLinePrefix(padSize, lineNumber) {
    var value = '';
    if (lineNumber !== undefined) {
        value = lineNumber.toString();
    }
    return value.padEnd(padSize !== null && padSize !== void 0 ? padSize : 4, ' ') + " | ";
}
/**
 * Render error block visualization.
 *
 * Example:
```
 1 | # line before
 2 | 0bA # line with the error
   | ^^^ # error visualization
 3 | # line after
```
 */
function renderErrorVisualization(lines, errorLocation, prefixWidth, firstLineIndex, startPosition) {
    var e_1, _a;
    var output = '';
    var position = startPosition;
    var currentLine = firstLineIndex;
    try {
        for (var lines_1 = __values(lines), lines_1_1 = lines_1.next(); !lines_1_1.done; lines_1_1 = lines_1.next()) {
            var line = lines_1_1.value;
            output += formatLinePrefix(prefixWidth, currentLine);
            output += line + '\n';
            // Check if this line intersects with the error span
            if (position <= errorLocation.end.charIndex &&
                position + line.length >= errorLocation.start.charIndex) {
                output += formatLinePrefix(prefixWidth);
                // Iterate over the characters of the current line
                // If the character is part of the error span, add ^ underneath
                // If it isn't either add a space or, if the character is tab, add a tab
                for (var i = 0; i < line.length; i += 1) {
                    if (i >= errorLocation.start.charIndex - position &&
                        i < errorLocation.end.charIndex - position) {
                        output += '^';
                    }
                    else {
                        if (line.charAt(i) === '\t') {
                            output += '\t';
                        }
                        else {
                            output += ' ';
                        }
                    }
                }
                output += '\n';
            }
            position += line.length;
            currentLine += 1;
            // For newline
            position += 1;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (lines_1_1 && !lines_1_1.done && (_a = lines_1.return)) _a.call(lines_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return output;
}
/**
 * Generates and renders error block visualization given the span, location and source.
 */
function generateErrorVisualization(source, location) {
    var visBlock = computeVisualizeBlockSpan(source.body, location);
    // Location within the body plus the offset of the Source metadata.
    var sourceLocation = source.applyLocationOffset(location);
    // Slice of the source that encompasses the token and is
    // delimited by newlines or file boundaries
    var sourceTextSlice = source.body.slice(visBlock.start, visBlock.end);
    var sourceTextLines = sourceTextSlice.split('\n');
    var maxLineNumberLog = Math.log10(sourceLocation.start.line + sourceTextLines.length) + 1;
    var visualization = renderErrorVisualization(sourceTextLines, location, maxLineNumberLog, sourceLocation.start.line + visBlock.lineOffset, visBlock.start);
    return {
        visualization: visualization,
        maxLineNumberLog: maxLineNumberLog,
        sourceLocation: sourceLocation,
    };
}
var SyntaxError = /** @class */ (function () {
    function SyntaxError(
    /** Input source that is being parsed. */
    source, 
    /** Location of the error. */
    location, 
    /** Category of this error. */
    category, detail, 
    /** Optional hint that is emitted to help with the resolution. */
    hint) {
        this.source = source;
        this.location = location;
        this.category = category;
        this.hint = hint;
        this.detail = detail !== null && detail !== void 0 ? detail : 'Invalid or unexpected token';
    }
    SyntaxError.fromSyntaxRuleNoMatch = function (source, result) {
        var _a, _b;
        var actual = '<NONE>';
        if (result.attempts.token !== undefined) {
            var fmt = token_1.formatTokenData(result.attempts.token.data);
            switch (result.attempts.token.data.kind) {
                case 1 /* SEPARATOR */:
                case 2 /* OPERATOR */:
                case 3 /* LITERAL */:
                case 5 /* IDENTIFIER */:
                    actual = '`' + fmt.data + '`';
                    break;
                case 4 /* STRING */:
                    actual = '"' + fmt.data + '"';
                    break;
                case 0 /* UNKNOWN */:
                    return result.attempts.token.data.error;
                default:
                    actual = fmt.kind;
                    break;
            }
        }
        var location = (_b = (_a = result.attempts.token) === null || _a === void 0 ? void 0 : _a.location) !== null && _b !== void 0 ? _b : {
            start: { line: 0, column: 0, charIndex: 0 },
            end: { line: 0, column: 0, charIndex: 0 },
        };
        var expectedFilterSet = new Set();
        var expected = result.attempts.rules
            .map(function (r) { return r.toString(); })
            .filter(function (r) {
            if (expectedFilterSet.has(r)) {
                return false;
            }
            expectedFilterSet.add(r);
            return true;
        })
            .join(' or ');
        return new SyntaxError(source, location, "Parser" /* PARSER */, "Expected " + expected + " but found " + actual);
    };
    SyntaxError.prototype.format = function () {
        // Generate the lines
        var _a = generateErrorVisualization(this.source, this.location), visualization = _a.visualization, maxLineNumberLog = _a.maxLineNumberLog, sourceLocation = _a.sourceLocation;
        var categoryInfo = '';
        switch (this.category) {
            case "Jessie syntax" /* JESSIE_SYNTAX */:
            case "Jessie validation" /* JESSIE_VALIDATION */:
                categoryInfo = 'Error in script syntax: ';
                break;
        }
        var errorLine = "SyntaxError: " + categoryInfo + this.detail;
        var locationLinePrefix = ' '.repeat(maxLineNumberLog) + '--> ';
        var locationLine = "" + locationLinePrefix + this.source.fileName + ":" + sourceLocation.start.line + ":" + sourceLocation.start.column;
        var maybeHint = this.hint ? "Hint: " + this.hint + "\n" : '';
        return errorLine + "\n" + locationLine + "\n" + visualization + "\n" + maybeHint;
    };
    Object.defineProperty(SyntaxError.prototype, "message", {
        get: function () {
            // TODO
            return this.detail;
        },
        enumerable: false,
        configurable: true
    });
    return SyntaxError;
}());
exports.SyntaxError = SyntaxError;
//# sourceMappingURL=error.js.map