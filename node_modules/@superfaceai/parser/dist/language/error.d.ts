import { CharIndexSpan, LocationSpan, Source } from './source';
import { RuleResultNoMatch } from './syntax/rule';
export declare const enum SyntaxErrorCategory {
    /** Lexer token error */
    LEXER = "Lexer",
    /** Parser rule error */
    PARSER = "Parser",
    /** Jessie syntax error */
    JESSIE_SYNTAX = "Jessie syntax",
    /** Jessie forbidden construct error */
    JESSIE_VALIDATION = "Jessie validation"
}
export declare type ProtoError = {
    /** Relative span of this error with respect to the token it is attached to. */
    readonly relativeSpan: CharIndexSpan;
    readonly detail?: string;
    readonly category: SyntaxErrorCategory;
    readonly hint?: string;
};
export declare class SyntaxError {
    /** Input source that is being parsed. */
    readonly source: Source;
    /** Location of the error. */
    readonly location: LocationSpan;
    /** Category of this error. */
    readonly category: SyntaxErrorCategory;
    /** Optional hint that is emitted to help with the resolution. */
    readonly hint?: string | undefined;
    /** Additional message attached to the error. */
    readonly detail: string;
    constructor(
    /** Input source that is being parsed. */
    source: Source, 
    /** Location of the error. */
    location: LocationSpan, 
    /** Category of this error. */
    category: SyntaxErrorCategory, detail?: string, 
    /** Optional hint that is emitted to help with the resolution. */
    hint?: string | undefined);
    static fromSyntaxRuleNoMatch(source: Source, result: RuleResultNoMatch): SyntaxError;
    format(): string;
    get message(): string;
}
