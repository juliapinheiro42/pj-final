"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryKeywordLiteral = exports.isNotValidIdentifierChar = exports.isAny = exports.isDecoratorChar = exports.isStringLiteralEscapeChar = exports.isStringLiteralChar = exports.isNewline = exports.isWhitespace = exports.countStartingIdentifierChars = exports.isValidIdentifierChar = exports.isValidIdentifierStartChar = exports.isDecimalSeparator = exports.countStartingNumbersRadix = exports.countStartingNumbers = exports.isHexadecimalNumber = exports.isDecimalNumber = exports.isOctalNumber = exports.isBinaryNumber = exports.countStartingLetters = exports.isLetter = exports.countStarting = void 0;
/**
 * Counts starting characters from `str` as long as `predicate` returns true.
 *
 * Returns number of characters at the start of the string that match predicate.
 *
 * This function is basically a find over the input string with the predicate.
 */
function countStarting(predicate, str) {
    var position = 0;
    var code = str.charCodeAt(position);
    while (!isNaN(code) && predicate(code)) {
        position += 1;
        code = str.charCodeAt(position);
    }
    return position;
}
exports.countStarting = countStarting;
// Common scanner checks
function isLetter(char) {
    // A-Z, a-z
    return (char >= 65 && char <= 90) || (char >= 97 && char <= 122);
}
exports.isLetter = isLetter;
exports.countStartingLetters = countStarting.bind(undefined, isLetter);
function isBinaryNumber(char) {
    // 0, 1
    return char === 48 || char === 49;
}
exports.isBinaryNumber = isBinaryNumber;
function isOctalNumber(char) {
    // 0-7
    return char >= 48 && char <= 55;
}
exports.isOctalNumber = isOctalNumber;
function isDecimalNumber(char) {
    // 0-9
    return char >= 48 && char <= 57;
}
exports.isDecimalNumber = isDecimalNumber;
function isHexadecimalNumber(char) {
    // 0-9, A-F, a-f
    return ((char >= 48 && char <= 57) ||
        (char >= 65 && char <= 70) ||
        (char >= 97 && char <= 102));
}
exports.isHexadecimalNumber = isHexadecimalNumber;
exports.countStartingNumbers = countStarting.bind(undefined, isDecimalNumber);
function countStartingNumbersRadix(str, radix) {
    switch (radix) {
        case 2:
            return countStarting(isBinaryNumber, str);
        case 8:
            return countStarting(isOctalNumber, str);
        case 10:
            return countStarting(isDecimalNumber, str);
        case 16:
            return countStarting(isHexadecimalNumber, str);
        default:
            throw "Radix " + radix + " is not supported (supported: 2, 8, 10, 16).";
    }
}
exports.countStartingNumbersRadix = countStartingNumbersRadix;
function isDecimalSeparator(char) {
    return char === 46;
}
exports.isDecimalSeparator = isDecimalSeparator;
function isValidIdentifierStartChar(char) {
    // _
    return char === 95 || isLetter(char);
}
exports.isValidIdentifierStartChar = isValidIdentifierStartChar;
function isValidIdentifierChar(char) {
    return isValidIdentifierStartChar(char) || isDecimalNumber(char);
}
exports.isValidIdentifierChar = isValidIdentifierChar;
exports.countStartingIdentifierChars = countStarting.bind(undefined, isValidIdentifierChar);
function isWhitespace(char) {
    // tab, space, BOM, newline
    return char === 9 || char === 32 || char === 0xfeff || char === 10;
}
exports.isWhitespace = isWhitespace;
function isNewline(char) {
    return char === 10;
}
exports.isNewline = isNewline;
function isStringLiteralChar(char) {
    // ", '
    return char === 34 || char === 39;
}
exports.isStringLiteralChar = isStringLiteralChar;
function isStringLiteralEscapeChar(char) {
    // \
    return char === 92;
}
exports.isStringLiteralEscapeChar = isStringLiteralEscapeChar;
function isDecoratorChar(char) {
    // @
    return char === 64;
}
exports.isDecoratorChar = isDecoratorChar;
// Keyword scanner checks
function isAny(_) {
    return true;
}
exports.isAny = isAny;
function isNotValidIdentifierChar(char) {
    return !isValidIdentifierChar(char);
}
exports.isNotValidIdentifierChar = isNotValidIdentifierChar;
/**
 * Tries parsing the following characters to match the specified keyword and be followed
 * by a character matching an optional predicate.
 *
 * If the predicate is not specified, the default predicate is `isNotValidIdentifierChar`
 */
function tryKeywordLiteral(str, keyword, ret, charAfterPredicate) {
    if (str.startsWith(keyword)) {
        var checkPredicate = charAfterPredicate !== null && charAfterPredicate !== void 0 ? charAfterPredicate : isNotValidIdentifierChar;
        var charAfter = str.charCodeAt(keyword.length);
        if (!checkPredicate(charAfter)) {
            return undefined;
        }
        return {
            value: ret,
            length: keyword.length,
        };
    }
    else {
        return undefined;
    }
}
exports.tryKeywordLiteral = tryKeywordLiteral;
//# sourceMappingURL=util.js.map