import { SyntaxError } from '../error';
import { LocationSpan } from '../source';
/** Supported termination tokens */
export declare type TerminationTokens = ';' | ',' | '\n' | ')' | ']' | '}';
/** Enum describing the different kinds of tokens that the lexer emits. */
export declare const enum LexerTokenKind {
    /** Token unknown to the lexer. */
    UNKNOWN = 0,
    SEPARATOR = 1,
    OPERATOR = 2,
    /** Number or boolean literal. */
    LITERAL = 3,
    STRING = 4,
    IDENTIFIER = 5,
    COMMENT = 6,
    NEWLINE = 7,
    JESSIE_SCRIPT = 8
}
export declare type LexerScanRule<T> = [T, (_: number) => boolean];
export declare type SeparatorFile = 'SOF' | 'EOF';
export declare type SeparatorParen = '(' | ')';
export declare type SeparatorBracket = '[' | ']';
export declare type SeparatorBrace = '{' | '}';
export declare type SeparatorValue = SeparatorFile | SeparatorParen | SeparatorBracket | SeparatorBrace;
export declare const SEPARATORS: {
    [P in SeparatorParen | SeparatorBracket | SeparatorBrace]: LexerScanRule<P>;
};
export declare type OperatorValue = ':' | '!' | '|' | '=' | '@' | ',' | ';' | '.';
export declare const OPERATORS: {
    [P in OperatorValue]: LexerScanRule<P>;
};
export declare const LITERALS_BOOL: Record<string, LexerScanRule<boolean>>;
export declare type LiteralValue = number | boolean;
export declare type StringValue = string;
export declare type IdentifierValue = string;
export declare type CommentValue = string;
export declare type JessieScriptValue = string;
export interface UnknownTokenData {
    kind: LexerTokenKind.UNKNOWN;
    error: SyntaxError;
}
export interface SeparatorTokenData {
    kind: LexerTokenKind.SEPARATOR;
    separator: SeparatorValue;
}
export interface OperatorTokenData {
    kind: LexerTokenKind.OPERATOR;
    operator: OperatorValue;
}
export interface LiteralTokenData {
    kind: LexerTokenKind.LITERAL;
    literal: LiteralValue;
}
export interface StringTokenData {
    kind: LexerTokenKind.STRING;
    string: StringValue;
}
export interface IdentifierTokenData {
    kind: LexerTokenKind.IDENTIFIER;
    identifier: IdentifierValue;
}
export interface CommentTokenData {
    kind: LexerTokenKind.COMMENT;
    comment: CommentValue;
}
export interface NewlineTokenData {
    kind: LexerTokenKind.NEWLINE;
}
export interface JessieScriptTokenData {
    kind: LexerTokenKind.JESSIE_SCRIPT;
    script: JessieScriptValue;
    sourceScript: string;
    sourceMap: string;
}
export declare type DefaultSublexerTokenData = UnknownTokenData | SeparatorTokenData | OperatorTokenData | LiteralTokenData | StringTokenData | IdentifierTokenData | CommentTokenData | NewlineTokenData;
export declare type JessieSublexerTokenData = JessieScriptTokenData;
export declare type LexerTokenData = DefaultSublexerTokenData | JessieSublexerTokenData;
export declare function formatTokenKind(kind: LexerTokenKind): string;
export declare function formatTokenData(data: LexerTokenData): {
    kind: string;
    data: string;
};
export declare class LexerToken {
    /** Data of the token. */
    readonly data: LexerTokenData;
    readonly location: LocationSpan;
    constructor(
    /** Data of the token. */
    data: LexerTokenData, location: LocationSpan);
    isSOF(): boolean;
    isEOF(): boolean;
    toStringDebug(): string;
    toString(): string;
    [Symbol.toStringTag](): string;
}
