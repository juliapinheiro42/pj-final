"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryParseStringLiteral = void 0;
var util = __importStar(require("../../util"));
function resolveStringLiteralEscape(slice) {
    var firstChar = slice.charCodeAt(0);
    var result;
    switch (firstChar) {
        case 34:
            result = '"';
            break;
        case 39:
            result = "'";
            break;
        case 92:
            result = '\\';
            break;
        case 110:
            result = '\n';
            break;
        case 114:
            result = '\r';
            break;
        case 116:
            result = '\t';
            break;
        default:
            return undefined;
    }
    return {
        value: result,
        length: 1,
    };
}
/**
 * Returns the index of the first and last string in the array that is non-empty.
 *
 * Returns `[-1, -1]` if no non-empty lines are found.
 */
function firstLastNonempty(lines) {
    var first = -1;
    var last = -1;
    for (var i = 0; i < lines.length; i += 1) {
        if (lines[i].trim() !== '') {
            last = i;
            if (first === -1) {
                first = i;
            }
        }
    }
    return [first, last];
}
/** Returns the greatest common substring at the start both of `a` and `b`. */
function commonPrefix(a, b) {
    var common = '';
    var len = Math.min(a.length, b.length);
    for (var i = 0; i < len; i += 1) {
        if (a[i] !== b[i]) {
            break;
        }
        common += a[i];
    }
    return common;
}
function transformBlockStringValue(string) {
    var lines = string.split('\n');
    var _a = __read(firstLastNonempty(lines), 2), nonemptyStart = _a[0], nonemptyEnd = _a[1];
    // This is ok because `slice(-1, 0)` returns an empty array for which we check next
    var nonemptyLines = lines.slice(nonemptyStart, nonemptyEnd + 1);
    if (nonemptyLines.length === 0) {
        return '';
    }
    var leadingIndentCount = util.countStarting(function (char) { return util.isWhitespace(char); }, nonemptyLines[0]);
    var commonIndent = nonemptyLines.reduce(function (acc, curr) { return commonPrefix(acc, curr); }, nonemptyLines[0].slice(0, leadingIndentCount));
    var output = nonemptyLines
        .map(function (line) { return line.slice(commonIndent.length); })
        .join('\n');
    return output;
}
/**
 * Tries to parse a string literal token at current position.
 *
 * Returns nomatch if the current position cannot contain a string literal.
 *
 * Returns an error if parsing fails.
 */
function tryParseStringLiteral(slice) {
    var firstChar = slice.charCodeAt(0);
    if (!util.isStringLiteralChar(firstChar)) {
        return {
            kind: 'nomatch',
            tokenKind: 4 /* STRING */,
        };
    }
    var startingQuoteChars = util.countStarting(function (char) { return char === firstChar; }, slice);
    // Special case where the string is empty ('' or "")
    if (startingQuoteChars === 2) {
        return {
            kind: 'match',
            data: {
                kind: 4 /* STRING */,
                string: '',
            },
            relativeSpan: { start: 0, end: 2 },
        };
    }
    // Special case where a triple-quoted string is empty ('''''' or """""")
    if (startingQuoteChars >= 6) {
        return {
            kind: 'match',
            data: {
                kind: 4 /* STRING */,
                string: '',
            },
            relativeSpan: { start: 0, end: 6 },
        };
    }
    // In case there are 4 or 5 quote chars in row, we treat the 4th and 5th as part of the string itself.
    if (startingQuoteChars > 3) {
        startingQuoteChars = 3;
    }
    /** non-block strings allow escaping characters, so the predicate must different */
    var nonquotePredicate;
    if (startingQuoteChars === 1) {
        nonquotePredicate = function (char) {
            return char !== firstChar && !util.isStringLiteralEscapeChar(char);
        };
    }
    else {
        nonquotePredicate = function (char) { return char !== firstChar; };
    }
    // Now parse the body of the string
    var resultString = '';
    var restSlice = slice.slice(startingQuoteChars);
    var eatenChars = startingQuoteChars;
    // Closure to reduce repeating
    var eatChars = function (count, add) {
        if (typeof add === 'string') {
            resultString += add;
        }
        else if (add !== null && add !== void 0 ? add : true) {
            resultString += restSlice.slice(0, count);
        }
        restSlice = restSlice.slice(count);
        eatenChars += count;
    };
    for (;;) {
        // Eat all nonquote chars and update the count
        var nonquoteChars = util.countStarting(nonquotePredicate, restSlice);
        eatChars(nonquoteChars);
        // Now we hit either:
        // * Quote chars
        // * Escape chars
        // * EOF
        var nextChar = restSlice.charCodeAt(0);
        if (isNaN(nextChar)) {
            return {
                kind: 'error',
                tokenKind: 4 /* STRING */,
                errors: [
                    {
                        relativeSpan: { start: 0, end: eatenChars },
                        detail: 'Unexpected EOF',
                        category: "Lexer" /* LEXER */,
                    },
                ],
            };
        }
        else if (util.isStringLiteralEscapeChar(nextChar)) {
            // Eat the backslash
            eatChars(1, false);
            var escapeResult = resolveStringLiteralEscape(restSlice);
            if (escapeResult === undefined) {
                return {
                    kind: 'error',
                    tokenKind: 4 /* STRING */,
                    errors: [
                        {
                            relativeSpan: { start: 0, end: eatenChars + 1 },
                            detail: 'Invalid escape sequence',
                            category: "Lexer" /* LEXER */,
                        },
                    ],
                };
            }
            eatChars(escapeResult.length, escapeResult.value);
        }
        else if (nextChar === firstChar) {
            var quoteChars = util.countStarting(function (char) { return char === firstChar; }, restSlice);
            // Check for string literal end
            if (quoteChars >= startingQuoteChars) {
                // Make sure to only eat matching number of quote chars at the end
                eatenChars += startingQuoteChars;
                break;
            }
            // Just some quote chars inside the literal, moving on
            eatChars(quoteChars);
        }
        else {
            throw 'Invalid lexer state. This in an error in the lexer.';
        }
    }
    if (startingQuoteChars === 3) {
        resultString = transformBlockStringValue(resultString);
    }
    return {
        kind: 'match',
        data: {
            kind: 4 /* STRING */,
            string: resultString,
        },
        relativeSpan: { start: 0, end: eatenChars },
    };
}
exports.tryParseStringLiteral = tryParseStringLiteral;
//# sourceMappingURL=string.js.map