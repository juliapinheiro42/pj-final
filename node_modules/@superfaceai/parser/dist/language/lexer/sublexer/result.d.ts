import { ProtoError } from '../../error';
import { CharIndexSpan } from '../../source';
import { LexerTokenData, LexerTokenKind } from '../token';
/** The match is successful */
declare type ParseResultMatch<T extends LexerTokenData> = {
    readonly kind: 'match';
    readonly data: T;
    readonly relativeSpan: CharIndexSpan;
};
/** The match cannot happen here, further rules should be attempted */
declare type ParseResultNomatch = {
    readonly kind: 'nomatch';
    /** Kind of the token that cannot be parsed. */
    readonly tokenKind: LexerTokenKind;
};
/** The match would happen here but there was an error in the input */
declare type ParseResultError<E extends ProtoError> = {
    readonly kind: 'error';
    /** Kind of the token that would be parsed. */
    readonly tokenKind: LexerTokenKind;
    readonly errors: E[];
};
export declare type ParseResult<T extends LexerTokenData, E extends ProtoError = ProtoError> = ParseResultMatch<T> | ParseResultNomatch | ParseResultError<E>;
export {};
