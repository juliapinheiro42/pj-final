"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryParseJessieScriptExpression = void 0;
var ts = __importStar(require("typescript"));
var jessie_1 = require("../../../jessie");
function processScriptText(scriptText) {
    var SCRIPT_WRAP = {
        start: 'let __jessieValue = ',
        end: ';',
        transpiled: {
            start: 'var __jessieValue = ',
            end: ';',
            varName: '__jessieValue',
        },
    };
    // Diagnose the script text, put it in a position where an expression would be required
    var transRes = jessie_1.validateAndTranspile(SCRIPT_WRAP.start + scriptText + SCRIPT_WRAP.end);
    if (transRes.kind === 'failure') {
        return {
            kind: 'error',
            tokenKind: 8 /* JESSIE_SCRIPT */,
            // map the errors to get the correct spans
            errors: transRes.errors.map(function (err) {
                return {
                    detail: err.detail,
                    hint: err.hint,
                    category: err.category,
                    relativeSpan: {
                        start: err.relativeSpan.start - SCRIPT_WRAP.start.length,
                        end: err.relativeSpan.end - SCRIPT_WRAP.start.length,
                    },
                };
            }),
        };
    }
    // With some syntax the transpiler creates a polyfill for the function
    // For example for the spread operator `...`
    // Here we detect that case and wrap the output in an immediatelly invoked function expression
    var scriptOutput = transRes.output;
    if (!transRes.output.startsWith(SCRIPT_WRAP.transpiled.start)) {
        scriptOutput = "(function() {\n" + scriptOutput + "\nreturn " + SCRIPT_WRAP.transpiled.varName + ";\n})()";
    }
    else {
        // strip the prefix and postfix added by the processing here (to force expression position)
        scriptOutput = scriptOutput.slice(SCRIPT_WRAP.transpiled.start.length, scriptOutput.length - SCRIPT_WRAP.transpiled.end.length);
    }
    return {
        kind: 'match',
        data: {
            kind: 8 /* JESSIE_SCRIPT */,
            script: scriptOutput,
            sourceScript: scriptText,
            sourceMap: transRes.sourceMap,
        },
        relativeSpan: { start: 0, end: scriptText.length },
    };
}
// Static SCANNER to avoid reinitializing it, same thing is done inside TS codebase.
var SCANNER = ts.createScanner(ts.ScriptTarget.Latest, false, ts.LanguageVariant.Standard);
var TERMINATION_TOKEN_TO_TS_TOKEN = {
    ';': ts.SyntaxKind.SemicolonToken,
    ')': ts.SyntaxKind.CloseParenToken,
    '}': ts.SyntaxKind.CloseBraceToken,
    ']': ts.SyntaxKind.CloseBracketToken,
    ',': ts.SyntaxKind.CommaToken,
    '\n': ts.SyntaxKind.NewLineTrivia,
};
/** empty statements are not supported in jessie, so ; is a good fallback */
var FALLBACK_TERMINATOR_TOKENS = [';'];
/** Tokens that are always terminator token */
var HARD_TERMINATOR_TOKENS = [
    ts.SyntaxKind.EndOfFileToken,
    ts.SyntaxKind.SingleLineCommentTrivia,
];
var NESTED_OPEN_TOKENS = [
    ts.SyntaxKind.OpenBraceToken,
    ts.SyntaxKind.OpenBracketToken,
    ts.SyntaxKind.OpenParenToken, // (
];
var NESTED_CLOSE_TOKENS = [
    ts.SyntaxKind.CloseBraceToken,
    ts.SyntaxKind.CloseBracketToken,
    ts.SyntaxKind.CloseParenToken, // )
];
function tryParseJessieScriptExpression(slice, terminationTokens) {
    // need at least one terminator token, so we always fall back to something
    var termTokensMut = terminationTokens;
    if (termTokensMut === undefined || termTokensMut.length === 0) {
        termTokensMut = FALLBACK_TERMINATOR_TOKENS;
    }
    var termTokens = termTokensMut.map(function (tok) { return TERMINATION_TOKEN_TO_TS_TOKEN[tok]; });
    // Set the scanner text thus reusing the old scanner instance
    SCANNER.setText(slice);
    // Counts the number of open (), [] and {} pairs.
    var depthCounter = 0;
    // Keeps track of whether we are inside a (nested) template string.
    // The Typescript scanner produces a `}` token for the closing part of the template expression (the `${expr}`).
    // We need to manually detect this case and ask the scanner to rescan it with this in mind.
    var templateStringDepthCounter = 0;
    // Stores position after last valid token.
    var lastTokenEnd = 0;
    for (;;) {
        var token = SCANNER.scan();
        if (templateStringDepthCounter > 0) {
            // When `}` is found and we are inside a template string, issue a rescan.
            // This will either produce the TemplateMiddle token or a TemplateTail token.
            if (token === ts.SyntaxKind.CloseBraceToken) {
                SCANNER.reScanTemplateToken(false);
                token = SCANNER.getToken();
            }
            // End the template token context if tail is found
            if (token === ts.SyntaxKind.TemplateTail) {
                templateStringDepthCounter -= 1;
            }
        }
        if (token === ts.SyntaxKind.TemplateHead) {
            templateStringDepthCounter += 1;
        }
        // Look ahead for a termination token
        if (depthCounter === 0 &&
            templateStringDepthCounter === 0 &&
            (termTokens.includes(token) || HARD_TERMINATOR_TOKENS.includes(token))) {
            break;
        }
        lastTokenEnd = SCANNER.getTextPos();
        // Count bracket depth
        if (NESTED_OPEN_TOKENS.includes(token)) {
            depthCounter += 1;
        }
        else if (NESTED_CLOSE_TOKENS.includes(token)) {
            depthCounter -= 1;
        }
    }
    var scriptText = slice.slice(0, lastTokenEnd);
    return processScriptText(scriptText);
}
exports.tryParseJessieScriptExpression = tryParseJessieScriptExpression;
//# sourceMappingURL=expression.js.map