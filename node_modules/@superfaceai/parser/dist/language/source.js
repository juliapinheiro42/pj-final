"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeEndLocation = exports.Source = void 0;
var crypto_1 = require("crypto");
var util_1 = require("./lexer/util");
/** Source text with additionaly metadata. */
var Source = /** @class */ (function () {
    function Source(body, fileName, fileLocationOffset) {
        this.body = body;
        this.fileName = fileName !== null && fileName !== void 0 ? fileName : '[input]';
        this.fileLocationOffset = fileLocationOffset !== null && fileLocationOffset !== void 0 ? fileLocationOffset : { line: 0, column: 0 };
    }
    Source.prototype.checksum = function () {
        var hash = crypto_1.createHash('sha256');
        hash.update(this.body);
        return hash.digest('hex');
    };
    Source.prototype.applyLocationOffset = function (location) {
        var startColumnShift = location.start.line === 1 ? this.fileLocationOffset.column : 0;
        var endColumnShift = location.end.line === 1 ? this.fileLocationOffset.column : 0;
        return {
            start: {
                line: this.fileLocationOffset.line + location.start.line,
                column: location.start.column + startColumnShift,
                charIndex: location.start.charIndex,
            },
            end: {
                line: this.fileLocationOffset.line + location.end.line,
                column: location.end.column + endColumnShift,
                charIndex: location.end.charIndex,
            },
        };
    };
    return Source;
}());
exports.Source = Source;
/**
 * Computes the location of the end of the slice given the starting location.
 *
 * The final location is affected by newlines contained in the `slice`.
 */
function computeEndLocation(slice, startLocation) {
    var charArray = Array.from(slice);
    var _a = __read(charArray.reduce(function (acc, char, index) {
        if (util_1.isNewline(char.charCodeAt(0))) {
            acc[0] += 1;
            acc[1] = index;
        }
        return acc;
    }, [0, undefined]), 2), newlines = _a[0], newlineOffset = _a[1];
    var column;
    if (newlineOffset === undefined) {
        // If no newlines were found the new column is just the old column plus the slice length
        column = startLocation.column + slice.length;
    }
    else {
        column = slice.length - newlineOffset;
    }
    return {
        line: startLocation.line + newlines,
        column: column,
        charIndex: startLocation.charIndex + slice.length,
    };
}
exports.computeEndLocation = computeEndLocation;
//# sourceMappingURL=source.js.map