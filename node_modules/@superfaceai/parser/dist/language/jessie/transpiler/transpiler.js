"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transpileScript = void 0;
var ts = __importStar(require("typescript"));
var SCRIPT_OUTPUT_TARGET = ts.ScriptTarget.ES3;
var AFTER_TRANSFORMERS = [];
function transpileScript(input, reportDiagnostics) {
    var _a, _b, _c;
    // This will transpile the code, generate a source map and run transformers
    var _d = ts.transpileModule(input, {
        compilerOptions: {
            allowJs: true,
            target: SCRIPT_OUTPUT_TARGET,
            sourceMap: true,
        },
        transformers: {
            after: AFTER_TRANSFORMERS,
        },
        reportDiagnostics: reportDiagnostics,
    }), outputText = _d.outputText, diagnostics = _d.diagnostics, sourceMapText = _d.sourceMapText;
    // Strip the source mapping comment from the end of the output
    var outputTextStripped = outputText
        .replace('//# sourceMappingURL=module.js.map', '')
        .trimRight();
    // `sourceMapText` will be here because we requested it by setting the compiler flag
    if (!sourceMapText) {
        throw 'Source map text is not present';
    }
    var sourceMapJson = JSON.parse(sourceMapText);
    function assertSourceMapFormat(input) {
        // This is necessary because TypeScript cannot correctly narrow type of object properties yet
        var hasMappings = function (inp) {
            return typeof inp === 'object' && inp !== null && 'mappings' in inp;
        };
        if (!hasMappings(input) || typeof input.mappings !== 'string') {
            throw 'Source map JSON is not an object in the correct format';
        }
    }
    assertSourceMapFormat(sourceMapJson);
    var syntaxProtoError;
    if (diagnostics && diagnostics.length > 0) {
        var diag = diagnostics[0];
        var detail = diag.messageText;
        if (typeof detail === 'object') {
            detail = detail.messageText;
        }
        syntaxProtoError = {
            category: "Jessie syntax" /* JESSIE_SYNTAX */,
            relativeSpan: {
                start: (_a = diag.start) !== null && _a !== void 0 ? _a : 0,
                end: ((_b = diag.start) !== null && _b !== void 0 ? _b : 0) + Math.max(1, (_c = diag.length) !== null && _c !== void 0 ? _c : 0),
            },
            detail: detail,
        };
    }
    return {
        output: outputTextStripped,
        syntaxProtoError: syntaxProtoError,
        sourceMap: sourceMapJson.mappings,
    };
}
exports.transpileScript = transpileScript;
//# sourceMappingURL=transpiler.js.map