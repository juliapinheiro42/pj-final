"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProfileProvider = exports.BoundProfileProvider = void 0;
var ast_1 = require("@superfaceai/ast");
var debug_1 = __importDefault(require("debug"));
var fs_1 = require("fs");
var path_1 = require("path");
var errors_helpers_1 = require("../internal/errors.helpers");
var interpreter_1 = require("../internal/interpreter");
var variables_1 = require("../internal/interpreter/variables");
var parser_1 = require("../internal/parser");
var mutate_1 = require("../internal/superjson/mutate");
var lib_1 = require("../lib");
var fetch_1 = require("../lib/fetch");
var map_interpreter_adapter_1 = require("./failure/map-interpreter-adapter");
var profile_1 = require("./profile");
var provider_1 = require("./provider");
var registry_1 = require("./registry");
function forceCast(_) { }
function profileAstId(ast) {
    return ast.header.scope !== undefined
        ? ast.header.scope + '/' + ast.header.name
        : ast.header.name;
}
var boundProfileProviderDebug = debug_1.default('superface:bound-profile-provider');
var BoundProfileProvider = /** @class */ (function () {
    function BoundProfileProvider(profileAst, mapAst, providerName, configuration, events) {
        this.profileAst = profileAst;
        this.mapAst = mapAst;
        this.providerName = providerName;
        this.configuration = configuration;
        this.profileValidator = new interpreter_1.ProfileParameterValidator(this.profileAst);
        this.fetchInstance = new fetch_1.CrossFetch();
        this.fetchInstance.metadata = {
            profile: profileAstId(profileAst),
            provider: providerName,
        };
        this.fetchInstance.events = events;
    }
    BoundProfileProvider.prototype.composeInput = function (usecase, input) {
        var _a, _b;
        var composed = input;
        var defaultInput = variables_1.castToNonPrimitive((_b = (_a = this.configuration.profileProviderSettings) === null || _a === void 0 ? void 0 : _a.defaults[usecase]) === null || _b === void 0 ? void 0 : _b.input);
        if (defaultInput !== undefined) {
            composed = variables_1.mergeVariables(defaultInput, input !== null && input !== void 0 ? input : {});
            boundProfileProviderDebug('Composed input with defaults:', composed);
        }
        return composed;
    };
    /**
     * Performs the usecase while validating input and output against the profile definition.
     *
     * Note that the `TInput` and `TResult` types cannot be checked for compatibility with the profile definition, so the caller
     * is responsible for ensuring that the cast is safe.
     */
    BoundProfileProvider.prototype.perform = function (usecase, input, parameters) {
        return __awaiter(this, void 0, void 0, function () {
            var composedInput, inputValidation, interpreter, result, resultValidation;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.fetchInstance.metadata = {
                            profile: profileAstId(this.profileAst),
                            usecase: usecase,
                            provider: this.providerName,
                        };
                        composedInput = this.composeInput(usecase, input);
                        inputValidation = this.profileValidator.validate(composedInput, 'input', usecase);
                        if (inputValidation.isErr()) {
                            return [2 /*return*/, lib_1.err(inputValidation.error)];
                        }
                        forceCast(composedInput);
                        interpreter = new interpreter_1.MapInterpreter({
                            input: composedInput,
                            usecase: usecase,
                            serviceBaseUrl: this.configuration.baseUrl,
                            security: this.configuration.security,
                            parameters: this.mergeParameters(parameters, this.configuration.parameters),
                        }, {
                            fetchInstance: this.fetchInstance,
                            externalHandler: new map_interpreter_adapter_1.MapInterpreterEventAdapter(this.fetchInstance.metadata, this.fetchInstance.events),
                        });
                        return [4 /*yield*/, interpreter.perform(this.mapAst)];
                    case 1:
                        result = _a.sent();
                        if (result.isErr()) {
                            return [2 /*return*/, lib_1.err(result.error)];
                        }
                        resultValidation = this.profileValidator.validate(result.value, 'result', usecase);
                        if (resultValidation.isErr()) {
                            return [2 /*return*/, lib_1.err(resultValidation.error)];
                        }
                        forceCast(result.value);
                        return [2 /*return*/, lib_1.ok(result.value)];
                }
            });
        });
    };
    BoundProfileProvider.prototype.mergeParameters = function (parameters, providerParameters) {
        if (parameters === undefined) {
            return providerParameters;
        }
        if (providerParameters === undefined) {
            return parameters;
        }
        return __assign(__assign({}, providerParameters), parameters);
    };
    return BoundProfileProvider;
}());
exports.BoundProfileProvider = BoundProfileProvider;
var profileProviderDebug = debug_1.default('superface:profile-provider');
var ProfileProvider = /** @class */ (function () {
    function ProfileProvider(
    /** Preloaded superJson instance */
    //TODO: Use superJson from events/Client?
    superJson, 
    /** profile id, url, ast node or configuration instance */
    profile, 
    /** provider name, url or configuration instance */
    provider, events, 
    /** url or ast node */
    map) {
        this.superJson = superJson;
        this.profile = profile;
        this.provider = provider;
        this.events = events;
        this.map = map;
        if (this.profile instanceof profile_1.ProfileConfiguration) {
            this.profileId = this.profile.id;
        }
        else if (typeof this.profile === 'string') {
            this.profileId = this.profile;
        }
        else {
            this.profileId = profileAstId(this.profile);
        }
        var _a = __read(this.profileId.split('/'), 2), scopeOrProfileName = _a[0], profileName = _a[1];
        if (profileName === undefined) {
            this.profileName = scopeOrProfileName;
        }
        else {
            this.scope = scopeOrProfileName;
            this.profileName = profileName;
        }
    }
    /**
     * Binds the provider.
     *
     * This fetches the unspecified data (provider information and map ast) from registry.
     */
    ProfileProvider.prototype.bind = function (configuration) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function () {
            var profileAst, profileId, resolvedProviderInfo, providerInfo, providerName, securityValues, thisProviderName, resolvedMapAst, mapAst, mapVariant, mapRevision, fetchResponse, version, mapId, mapSource, serviceId, baseUrl, securityConfiguration;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0: return [4 /*yield*/, this.resolveProfileAst()];
                    case 1:
                        profileAst = _e.sent();
                        if (profileAst === undefined) {
                            throw errors_helpers_1.invalidProfileError(this.profileId);
                        }
                        profileId = profileAstId(profileAst);
                        return [4 /*yield*/, this.resolveProviderInfo()];
                    case 2:
                        resolvedProviderInfo = _e.sent();
                        providerInfo = resolvedProviderInfo.providerInfo;
                        providerName = resolvedProviderInfo.providerName;
                        securityValues = this.resolveSecurityValues(providerName, configuration === null || configuration === void 0 ? void 0 : configuration.security);
                        thisProviderName = typeof this.provider === 'string' ? this.provider : this.provider.name;
                        if (providerName !== thisProviderName) {
                            throw errors_helpers_1.providersDoNotMatchError(providerName, thisProviderName, 'provider.json');
                        }
                        return [4 /*yield*/, this.resolveMapAst(profileId + "." + providerName)];
                    case 3:
                        resolvedMapAst = _e.sent();
                        mapAst = resolvedMapAst.mapAst;
                        mapVariant = resolvedMapAst.mapVariant;
                        mapRevision = resolvedMapAst.mapRevision;
                        if (!(mapAst === undefined)) return [3 /*break*/, 8];
                        profileProviderDebug('Fetching map from store');
                        //throw error when we have remote map and local provider
                        if (providerInfo) {
                            throw errors_helpers_1.localProviderAndRemoteMapError(providerName, this.profileId);
                        }
                        return [4 /*yield*/, registry_1.fetchBind({
                                profileId: profileId +
                                    ("@" + profileAst.header.version.major + "." + profileAst.header.version.minor + "." + profileAst.header.version.patch),
                                provider: providerName,
                                mapVariant: mapVariant,
                                mapRevision: mapRevision,
                            })];
                    case 4:
                        fetchResponse = _e.sent();
                        providerInfo !== null && providerInfo !== void 0 ? providerInfo : (providerInfo = fetchResponse.provider);
                        mapAst = fetchResponse.mapAst;
                        if (!!mapAst) return [3 /*break*/, 7];
                        version = profileAst.header.version.major + "." + profileAst.header.version.minor + "." + profileAst.header.version.patch;
                        mapId = mapVariant
                            ? profileId + "." + providerName + "." + mapVariant + "@" + version
                            : profileId + "." + providerName + "@" + version;
                        return [4 /*yield*/, registry_1.fetchMapSource(mapId)];
                    case 5:
                        mapSource = _e.sent();
                        return [4 /*yield*/, parser_1.Parser.parseMap(mapSource, mapId, {
                                profileName: profileAst.header.name,
                                scope: profileAst.header.scope,
                                providerName: providerName,
                            })];
                    case 6:
                        mapAst = _e.sent();
                        _e.label = 7;
                    case 7: return [3 /*break*/, 10];
                    case 8:
                        if (!(providerInfo === undefined)) return [3 /*break*/, 10];
                        return [4 /*yield*/, registry_1.fetchProviderInfo(providerName)];
                    case 9:
                        // resolve only provider info if map is specified locally
                        providerInfo = _e.sent();
                        _e.label = 10;
                    case 10:
                        if (providerName !== mapAst.header.provider) {
                            throw errors_helpers_1.providersDoNotMatchError(mapAst.header.provider, providerName, 'map');
                        }
                        serviceId = providerInfo.defaultService;
                        baseUrl = (_a = providerInfo.services.find(function (s) { return s.id === serviceId; })) === null || _a === void 0 ? void 0 : _a.baseUrl;
                        if (baseUrl === undefined) {
                            throw errors_helpers_1.serviceNotFoundError(serviceId, providerName, serviceId === providerInfo.defaultService);
                        }
                        securityConfiguration = this.resolveSecurityConfiguration((_b = providerInfo.securitySchemes) !== null && _b !== void 0 ? _b : [], securityValues, providerName);
                        return [2 /*return*/, new BoundProfileProvider(profileAst, mapAst, providerInfo.name, {
                                baseUrl: baseUrl,
                                profileProviderSettings: (_c = this.superJson.normalized.profiles[profileId]) === null || _c === void 0 ? void 0 : _c.providers[providerInfo.name],
                                security: securityConfiguration,
                                parameters: this.resolveIntegrationParameters(providerInfo, (_d = this.superJson.normalized.providers[providerInfo.name]) === null || _d === void 0 ? void 0 : _d.parameters),
                            }, this.events)];
                }
            });
        });
    };
    ProfileProvider.prototype.resolveIntegrationParameters = function (providerJson, superJsonParameters) {
        var e_1, _a, e_2, _b;
        if (superJsonParameters === undefined) {
            return undefined;
        }
        var providerJsonParameters = providerJson.parameters || [];
        if (Object.keys(superJsonParameters).length !== 0 &&
            providerJsonParameters.length === 0) {
            console.warn('Warning: Super.json defines integration parameters but provider.json does not');
        }
        var result = {};
        var preparedParameters = ast_1.prepareProviderParameters(providerJson.name, providerJsonParameters);
        var _loop_1 = function (key, value) {
            var providerJsonParameter = providerJsonParameters.find(function (parameter) { return parameter.name === key; });
            // If value name and prepared value equals we are dealing with unset env
            if (providerJsonParameter &&
                preparedParameters[providerJsonParameter.name] === value) {
                if (providerJsonParameter.default) {
                    result[key] = providerJsonParameter.default;
                }
            }
            // Use original value
            if (!result[key]) {
                result[key] = value;
            }
        };
        try {
            // Resolve parameters defined in super.json
            for (var _c = __values(Object.entries(superJsonParameters)), _d = _c.next(); !_d.done; _d = _c.next()) {
                var _e = __read(_d.value, 2), key = _e[0], value = _e[1];
                _loop_1(key, value);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        try {
            // Resolve parameters which are missing in super.json and have default value
            for (var providerJsonParameters_1 = __values(providerJsonParameters), providerJsonParameters_1_1 = providerJsonParameters_1.next(); !providerJsonParameters_1_1.done; providerJsonParameters_1_1 = providerJsonParameters_1.next()) {
                var parameter = providerJsonParameters_1_1.value;
                if (result[parameter.name] === undefined && parameter.default) {
                    result[parameter.name] = parameter.default;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (providerJsonParameters_1_1 && !providerJsonParameters_1_1.done && (_b = providerJsonParameters_1.return)) _b.call(providerJsonParameters_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return result;
    };
    ProfileProvider.prototype.resolveProfileAst = function () {
        return __awaiter(this, void 0, void 0, function () {
            var resolveInput, profileAst;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        resolveInput = this.profile;
                        if (resolveInput instanceof profile_1.ProfileConfiguration) {
                            resolveInput = resolveInput.id;
                        }
                        return [4 /*yield*/, ProfileProvider.resolveValue(resolveInput, function (fileContents, fileName) { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    // If we have profile source, we parse
                                    if (fileName !== undefined && ast_1.isProfileFile(fileName)) {
                                        return [2 /*return*/, parser_1.Parser.parseProfile(fileContents, fileName, {
                                                profileName: this.profileName,
                                                scope: this.scope,
                                            })];
                                    }
                                    // Otherwise we return parsed
                                    return [2 /*return*/, ast_1.assertProfileDocumentNode(JSON.parse(fileContents))];
                                });
                            }); }, function (profileId) {
                                var profileSettings = _this.superJson.normalized.profiles[profileId];
                                if (profileSettings === undefined) {
                                    // not found at all
                                    return undefined;
                                }
                                else if ('file' in profileSettings) {
                                    // assumed right next to source file
                                    return (ast_1.FILE_URI_PROTOCOL + _this.superJson.resolvePath(profileSettings.file));
                                }
                                else {
                                    // assumed to be in grid folder
                                    return (ast_1.FILE_URI_PROTOCOL +
                                        _this.superJson.resolvePath(path_1.join('grid', profileId + "@" + profileSettings.version + ".supr")));
                                }
                            }, ['.ast.json', ''])];
                    case 1:
                        profileAst = _a.sent();
                        return [2 /*return*/, profileAst];
                }
            });
        });
    };
    ProfileProvider.prototype.resolveProviderInfo = function () {
        return __awaiter(this, void 0, void 0, function () {
            var resolveInput, providerInfo, providerName;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        resolveInput = this.provider;
                        if (resolveInput instanceof provider_1.ProviderConfiguration) {
                            resolveInput = resolveInput.name;
                        }
                        return [4 /*yield*/, ProfileProvider.resolveValue(resolveInput, function (fileContents) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                return [2 /*return*/, JSON.parse(fileContents)];
                            }); }); }, // TODO: validate
                            function (// TODO: validate
                            providerName) {
                                var providerSettings = _this.superJson.normalized.providers[providerName];
                                if ((providerSettings === null || providerSettings === void 0 ? void 0 : providerSettings.file) !== undefined) {
                                    // local file is resolved
                                    return (ast_1.FILE_URI_PROTOCOL +
                                        _this.superJson.resolvePath(providerSettings.file));
                                }
                                else {
                                    // local file not specified
                                    return undefined;
                                }
                            })];
                    case 1:
                        providerInfo = _a.sent();
                        if (providerInfo === undefined) {
                            // if the providerInfo is undefined then this must be a string that resolveValue returned undefined for.
                            forceCast(resolveInput);
                            providerName = resolveInput;
                        }
                        else {
                            providerName = providerInfo.name;
                        }
                        return [2 /*return*/, { providerInfo: providerInfo, providerName: providerName }];
                }
            });
        });
    };
    ProfileProvider.prototype.resolveMapAst = function (mapId) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var mapInfo, _b, providerName, mapAst;
            var _this = this;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        mapInfo = {};
                        _b = __read(mapId.split('.'), 2), providerName = _b[1];
                        return [4 /*yield*/, ProfileProvider.resolveValue((_a = this.map) !== null && _a !== void 0 ? _a : mapId, function (fileContents, fileName) { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    // If we have source, we parse
                                    if (fileName !== undefined && ast_1.isMapFile(fileName)) {
                                        return [2 /*return*/, parser_1.Parser.parseMap(fileContents, fileName, {
                                                profileName: this.profileName,
                                                providerName: providerName,
                                                scope: this.scope,
                                            })];
                                    }
                                    // Otherwise we return parsed
                                    return [2 /*return*/, ast_1.assertMapDocumentNode(JSON.parse(fileContents))];
                                });
                            }); }, function (mapId) {
                                var _a = __read(mapId.split('.'), 2), profileId = _a[0], providerName = _a[1];
                                var profileProviderSettings = _this.superJson.normalized.profiles[profileId].providers[providerName];
                                if (profileProviderSettings === undefined) {
                                    return undefined;
                                }
                                else if ('file' in profileProviderSettings) {
                                    return (ast_1.FILE_URI_PROTOCOL +
                                        _this.superJson.resolvePath(profileProviderSettings.file));
                                }
                                else {
                                    mapInfo.mapVariant = profileProviderSettings.mapVariant;
                                    mapInfo.mapRevision = profileProviderSettings.mapRevision;
                                    return undefined;
                                }
                            }, ['.ast.json', ''])];
                    case 1:
                        mapAst = _c.sent();
                        return [2 /*return*/, __assign({ mapAst: mapAst }, mapInfo)];
                }
            });
        });
    };
    /**
     * Returns the value resolved from the input.
     *
     * The recognized input values are:
     * * The value itself, returned straight away
     * * `undefined`, returned straight away
     * * File URI that is read and the contents are passed to the `parseFile` function
     * * For other values `unpackNested(input)` is called recursively
     */
    ProfileProvider.resolveValue = function (input, parseFile, unpackNested, extensions) {
        if (extensions === void 0) { extensions = ['']; }
        return __awaiter(this, void 0, void 0, function () {
            var fileName, contents, fileNameWithExtension, extensions_1, extensions_1_1, extension, e_3, e_4_1, nested;
            var e_4, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!(typeof input === 'string')) return [3 /*break*/, 13];
                        if (!ast_1.isFileURIString(input)) return [3 /*break*/, 11];
                        fileName = input.slice(ast_1.FILE_URI_PROTOCOL.length);
                        profileProviderDebug('Resolving input as file:', fileName);
                        contents = void 0, fileNameWithExtension = void 0;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 8, 9, 10]);
                        extensions_1 = __values(extensions), extensions_1_1 = extensions_1.next();
                        _b.label = 2;
                    case 2:
                        if (!!extensions_1_1.done) return [3 /*break*/, 7];
                        extension = extensions_1_1.value;
                        fileNameWithExtension = fileName + extension;
                        _b.label = 3;
                    case 3:
                        _b.trys.push([3, 5, , 6]);
                        return [4 /*yield*/, fs_1.promises.readFile(fileNameWithExtension, {
                                encoding: 'utf-8',
                            })];
                    case 4:
                        contents = _b.sent();
                        return [3 /*break*/, 7];
                    case 5:
                        e_3 = _b.sent();
                        void e_3;
                        return [3 /*break*/, 6];
                    case 6:
                        extensions_1_1 = extensions_1.next();
                        return [3 /*break*/, 2];
                    case 7: return [3 /*break*/, 10];
                    case 8:
                        e_4_1 = _b.sent();
                        e_4 = { error: e_4_1 };
                        return [3 /*break*/, 10];
                    case 9:
                        try {
                            if (extensions_1_1 && !extensions_1_1.done && (_a = extensions_1.return)) _a.call(extensions_1);
                        }
                        finally { if (e_4) throw e_4.error; }
                        return [7 /*endfinally*/];
                    case 10:
                        if (contents === undefined) {
                            throw errors_helpers_1.referencedFileNotFoundError(fileName, extensions);
                        }
                        return [2 /*return*/, parseFile(contents, fileNameWithExtension)];
                    case 11:
                        // TODO: detect remote url and fetch it, or call a callback?
                        profileProviderDebug('Resolving input as nested value:', input);
                        nested = unpackNested(input);
                        return [2 /*return*/, ProfileProvider.resolveValue(nested, parseFile, unpackNested)];
                    case 12: return [3 /*break*/, 14];
                    case 13: 
                    // return undefined and T
                    return [2 /*return*/, input];
                    case 14: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Resolves auth variables by applying the provided overlay over the base variables.
     *
     * The base variables either come from super.json or from `this.provider` if it is an instance of `ProviderConfiguration`
     */
    ProfileProvider.prototype.resolveSecurityValues = function (providerName, overlay) {
        var _a;
        var base;
        if (this.provider instanceof provider_1.ProviderConfiguration) {
            base = this.provider.security;
        }
        else {
            base = (_a = this.superJson.normalized.providers[providerName]) === null || _a === void 0 ? void 0 : _a.security;
        }
        var resolved = base;
        if (overlay !== undefined) {
            resolved = mutate_1.mergeSecurity(base, overlay);
        }
        return resolved;
    };
    ProfileProvider.prototype.resolveSecurityConfiguration = function (schemes, values, providerName) {
        var e_5, _a;
        var result = [];
        var _loop_2 = function (vals) {
            var scheme = schemes.find(function (scheme) { return scheme.id === vals.id; });
            if (scheme === undefined) {
                var definedSchemes = schemes.map(function (s) { return s.id; });
                throw errors_helpers_1.securityNotFoundError(providerName, definedSchemes, vals);
            }
            var invalidSchemeValuesErrorBuilder = function (scheme, values, requiredKeys) {
                var valueKeys = Object.keys(values).filter(function (k) { return k !== 'id'; });
                return errors_helpers_1.invalidSecurityValuesError(providerName, scheme.type, scheme.id, valueKeys, requiredKeys);
            };
            if (scheme.type === ast_1.SecurityType.APIKEY) {
                if (!ast_1.isApiKeySecurityValues(vals)) {
                    throw invalidSchemeValuesErrorBuilder(scheme, vals, ['apikey']);
                }
                result.push(__assign(__assign({}, scheme), vals));
            }
            else {
                switch (scheme.scheme) {
                    case ast_1.HttpScheme.BASIC:
                        if (!ast_1.isBasicAuthSecurityValues(vals)) {
                            throw invalidSchemeValuesErrorBuilder(scheme, vals, [
                                'username',
                                'password',
                            ]);
                        }
                        result.push(__assign(__assign({}, scheme), vals));
                        break;
                    case ast_1.HttpScheme.BEARER:
                        if (!ast_1.isBearerTokenSecurityValues(vals)) {
                            throw invalidSchemeValuesErrorBuilder(scheme, vals, ['token']);
                        }
                        result.push(__assign(__assign({}, scheme), vals));
                        break;
                    case ast_1.HttpScheme.DIGEST:
                        if (!ast_1.isDigestSecurityValues(vals)) {
                            throw invalidSchemeValuesErrorBuilder(scheme, vals, ['digest']);
                        }
                        result.push(__assign(__assign({}, scheme), vals));
                        break;
                }
            }
        };
        try {
            for (var values_1 = __values(values), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {
                var vals = values_1_1.value;
                _loop_2(vals);
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (values_1_1 && !values_1_1.done && (_a = values_1.return)) _a.call(values_1);
            }
            finally { if (e_5) throw e_5.error; }
        }
        return result;
    };
    return ProfileProvider;
}());
exports.ProfileProvider = ProfileProvider;
//# sourceMappingURL=profile-provider.js.map