import { FailurePolicyReason } from '../client/failure/policy';
import { SuperJson } from '../internal/superjson';
export declare const enum FailoverReason {
    NETWORK_ERROR_DNS = "NETWORK_ERROR_DNS",
    NETWORK_ERROR_SSL = "NETWORK_ERROR_SSL",
    NETWORK_ERROR_CONNECTION = "NETWORK_ERROR_CONNECTION",
    NETWORK_ERROR_TIMEOUT = "NETWORK_ERROR_TIMEOUT",
    REQUEST_ERROR_TIMEOUT = "REQUEST_ERROR_TIMEOUT",
    REQUEST_ERROR_ABORT = "REQUEST_ERROR_ABORT",
    HTTP_ERROR_500 = "HTTP_ERROR_500",
    UNEXPECTED_ERROR = "UNEXPECTED_ERROR"
}
declare type EventInputBase = {
    eventType: 'SDKInit' | 'PerformMetrics' | 'ProviderChange';
    occurredAt: Date;
};
export declare type SDKInitInput = EventInputBase & {
    eventType: 'SDKInit';
};
export declare type PerformMetricsInput = EventInputBase & {
    eventType: 'PerformMetrics';
    profile: string;
    provider: string;
    success: boolean;
};
export declare type ProviderChangeInput = EventInputBase & {
    eventType: 'ProviderChange';
    from: string;
    to?: string;
    profile: string;
    reasons?: {
        reason: FailurePolicyReason;
        occurredAt: Date;
    }[];
};
export declare type EventInput = SDKInitInput | PerformMetricsInput | ProviderChangeInput;
export declare class MetricReporter {
    private timer;
    private startTime;
    private fetchInstance;
    private readonly sdkToken;
    private performMetrics;
    private configHash;
    private anonymizedSuperJson;
    constructor(superJson: SuperJson);
    reportEvent(event: EventInput): void;
    flush(): void;
    private setTimer;
    private reportSdkInitEvent;
    private reportPerformMetricsEvent;
    private reportProviderChangeEvent;
    private createSDKInitEventPayload;
    private createProviderChangeEventPayload;
    private aggregateMetrics;
    private sendEvent;
}
export {};
